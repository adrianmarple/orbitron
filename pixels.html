<html>
<head>
<style>
body, html {
  width: 100%;
  height: 100%;
  margin: 0;
  background-color: black;
  display: flex;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100vh;
  max-width:  100vw;
  height: 100vh;
  max-height: 100vw;
  margin: 0;
}
</style>
<head>
<body>
<canvas width="1000" height="1000"></canvas>

<script>
  
let seed = 3
const PHI = (1 + Math.sqrt(5))/ 2
let verticies = []
let edges = []
let path = []
let isWall = false

function createRhombicosidodecahedron() {
  verticies = []
  baseVerticies = [
    [1, 1, Math.pow(PHI, 3)],
    [Math.pow(PHI, 2), PHI, 2 * PHI],
    [2 + PHI, 0 , Math.pow(PHI, 2)],
  ]

  for (let baseVertex of baseVerticies) {
    addPlusMinusVertex(baseVertex)
    addPlusMinusVertex([baseVertex[1], baseVertex[2], baseVertex[0]])
    addPlusMinusVertex([baseVertex[2], baseVertex[0], baseVertex[1]])
  }

  edges = []
  for (let i = 0; i < verticies.length; i++) {
    for (let j = i + 1; j < verticies.length; j++) {
      if (epsilonEquals(d(verticies[i].coordinates, verticies[j].coordinates), 2, 0.1)) {
        addEdge(verticies[i], verticies[j])
      }
    }
  }
  path = EulerianPath([0], verticies[0])
}

Y_GAP = 4.8
X_GAP = 2.75
function createWallTiling() {
  verticies = []
  edges = []
  addDodecagon([-2*X_GAP,0,0])
  addDodecagon([0,0,0])
  addDodecagon([2*X_GAP,0,0])
  addDodecagon([4*X_GAP,0,0])
  addDodecagon([-1*X_GAP,Y_GAP,0])
  addDodecagon([1*X_GAP,Y_GAP,0])
  addDodecagon([3*X_GAP,Y_GAP,0])
  addDodecagon([-1*X_GAP,-Y_GAP,0])
  addDodecagon([1*X_GAP,-Y_GAP,0])
  addDodecagon([3*X_GAP,-Y_GAP,0])
  path = EulerianPath([0], verticies[0])
}

DODEC_RADIUS = 3.86370335645
function addDodecagon(center) {
  let previousVertex = null
  let firstVertex = null
  for (let i = 0; i < 12; i++) {
    let angle = (-0.5 + i)/12 * 2 *Math.PI
    let vertex = addVertex([
      center[0] + Math.sin(angle) * DODEC_RADIUS,
      center[1] + Math.cos(angle) * DODEC_RADIUS,
      0])
    if (!firstVertex) {
      firstVertex = vertex
    }
    if (previousVertex) {
      addEdge(previousVertex, vertex)
    }
    previousVertex = vertex
  }
  addEdge(previousVertex, firstVertex)
}

function addPlusMinusVertex(vertex) {
  for (let i0 = -1; i0 <= 1; i0 += 2) {
    for (let i1 = -1; i1 <= 1; i1 += 2) {
      for (let i2 = -1; i2 <= 1; i2 += 2) {
        addVertex([i0 * vertex[0], i1 * vertex[1], i2 * vertex[2]]);
      }
    }
  }
}

function addVertex(coordinates) {
  for (let existingVertex of verticies) {
    if (epsilonEquals(d(existingVertex.coordinates, coordinates), 0, 0.1)) {
      return existingVertex
    }
  }
  let vertex = {
    adjacentVertices: [],
    edges: [],
    index: verticies.length,
    coordinates: coordinates,
  }
  verticies.push(vertex)
  return vertex
}

function addEdge(vertex1, vertex2) {
  let edge = {
    index: edges.length,
    verticies: [vertex1, vertex2],
  }
  edges.push(edge)
  vertex1.adjacentVertices.push(vertex2)
  vertex2.adjacentVertices.push(vertex1)
  vertex1.edges.push(edge)
  vertex2.edges.push(edge)
}


function EulerianPath(path, currentVertex) {
  if (path.length === edges.length) {
    return path
  }
  // TODO randomly distribute edges with fixed seed
  let edgesCopy = currentVertex.edges.slice()
  shuffle(edgesCopy)

  for (let edge of edgesCopy) {
    if (!path.includes(edge.index)) {
      let previousVertex = otherVertex(edges[path[path.length - 1]], currentVertex)
      let nextVertex = otherVertex(edge, currentVertex)
      let distance = d(previousVertex.coordinates, nextVertex.coordinates)
      if (!isWall && (epsilonEquals(distance, 2, 0.1) || epsilonEquals(distance, 3.236, 0.1))) {
        continue
      }

      path.push(edge.index);
      let finalPath = EulerianPath(path, nextVertex);
      if (finalPath) {
        return finalPath
      } else {
        path.pop()
      }
    }
  }
}

function otherVertex(edge, vertex) {
  let otherVertex = edge.verticies[0]
  if (otherVertex.index === vertex.index) {
    otherVertex = edge.verticies[1];
  }
  return otherVertex;
}

function outputPythonCoordinates() {
  let outputString = "[";
  let previousVertex = verticies[2];
  let count = 0;
  for (let index of path) {
    let edge = edges[index];
    let nextVertex = otherVertex(edge, previousVertex);
    let v1 = previousVertex.coordinates;
    let v2 = nextVertex.coordinates;
    outputString += "(" + linearCombo(v2, v1, 0/4) + "),";
    outputString += "(" + linearCombo(v2, v1, 1/4) + "),";
    outputString += "(" + linearCombo(v2, v1, 2/4) + "),";
    outputString += "(" + linearCombo(v2, v1, 3/4) + "),";

    previousVertex = nextVertex;
  }
  outputString += "]";
  return outputString;
}

function outputArduinoCoordinates() {
  let outputString = "switch(index){"
  let previousVertex = verticies[2];
  let count = 0;
  for (let index of path) {
    let edge = edges[index];
    let nextVertex = otherVertex(edge, previousVertex);
    let v1 = previousVertex.coordinates;
    let v2 = nextVertex.coordinates;
    outputString += vectorToString(linearCombo(v2, v1, 1/8));
    outputString += vectorToString(linearCombo(v2, v1, 3/8));
    outputString += vectorToString(linearCombo(v2, v1, 5/8));
    outputString += vectorToString(linearCombo(v2, v1, 7/8));

    previousVertex = nextVertex;
  }
  outputString += "};"
  return outputString;

  function vectorToString(v) {

    v = scale(v, 1/d(v, [0,0,0]));
    // const SCALE = 1000;
    // let value = SCALE/2 + Math.floor(SCALE/2 * v[0]);
    // value *= SCALE;
    // value += SCALE/2 + Math.floor(SCALE/2 * v[1]);
    // value *= SCALE;
    // value += SCALE/2 + Math.floor(SCALE/2 * v[2]);

    // let outputString = `case ${count}: return ${value};`;
    // count += 1;
    // return outputString;
    return `case ${count++}:c[0]=${v[0].toFixed(2)};c[1]=${v[1].toFixed(2)};c[2]=${v[2].toFixed(2)};return;`;
  }
}
// console.log(outputArduinoCoordinates())


const ROTATION_SCALE = 0.01
let previousXY = null
let isRotating = false
document.onmousedown = e => {
  isRotating = true
  previousXY = [e.clientX, e.clientY]
}
document.onmousemove = e => {
  if (isRotating && previousXY) {
    let newXY = [e.clientX, e.clientY]
    rotateX(-ROTATION_SCALE * (newXY[1] - previousXY[1]))
    rotateY(-ROTATION_SCALE * (newXY[0] - previousXY[0]))
    previousXY = newXY
  }
}
document.onmouseup = e => {
  isRotating = false
  previousXY = null
}

let pathIndex = 1;
document.onkeydown = e => {
  if (e.which === 39 || e.which === 38) {
    pathIndex += 1
  }
  if (e.which === 37 || e.which === 40) {
    pathIndex -= 1
  }
}


let c = document.querySelector("canvas")
let ctx = c.getContext("2d")

setInterval(render, 30)

function render() {
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 1000, 1000)

  let subPath = path.slice(0, pathIndex)

  let edgesCopy = edges.slice()
  edgesCopy.sort((a, b) => {
    return b.verticies[0].coordinates[2] - a.verticies[0].coordinates[2]
  })
  for (let edge of edgesCopy) {
    let xy0 = project(edge.verticies[0].coordinates)
    let xy1 = project(edge.verticies[1].coordinates)
    let z = edge.verticies[0].coordinates[2] + 5.5
    ctx.beginPath()

    let alpha = 2/z
    if (subPath.includes(edge.index)) {
      ctx.strokeStyle = `rgb(${255*alpha}, ${255*alpha}, ${255*alpha})`
    } else {
      ctx.strokeStyle = `rgb(${25*alpha}, ${25*alpha}, ${255*alpha})`
    }
    ctx.lineWidth = 100 / (z + 10)
    ctx.moveTo(xy0[0], xy0[1])
    ctx.lineTo(xy1[0], xy1[1])
    ctx.closePath()
    ctx.stroke()
  }
}


function epsilonEquals(a, b, epsilon) {
  return a - b < epsilon && b - a < epsilon
}

function d(v1, v2) {
  let difference = delta(v1, v2);
  return Math.sqrt(difference[0] * difference[0] +
                   difference[1] * difference[1] +
                   difference[2] * difference[2])
}
function delta(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]]
}

function project(v) {
  const SCALE = 800;
  let z = v[2] + 15;
  return [500 + v[0] * SCALE / z, 500 + v[1] * SCALE / z]
}

function rotateX(theta) {
  for (let vertex of verticies) {
    let v = vertex.coordinates
    vertex.coordinates = [
        v[0],
        v[1] * Math.cos(theta) + v[2] * Math.sin(theta),
        -v[1] * Math.sin(theta) + v[2] * Math.cos(theta)]
  }
}

function rotateY(theta) {
  for (let vertex of verticies) {
    let v = vertex.coordinates
    vertex.coordinates = [
        v[0] * Math.cos(theta) + v[2] * Math.sin(theta),
        v[1],
        -v[0] * Math.sin(theta) + v[2] * Math.cos(theta)]
  }
}

function scale(v, scalar) {
  return [v[0] * scalar, v[1] * scalar, v[2] * scalar]
}

function linearCombo(v1, v2, alpha) {
  return [
    v1[0] * alpha + v2[0] * (1 - alpha),
    v1[1] * alpha + v2[1] * (1 - alpha),
    v1[2] * alpha + v2[2] * (1 - alpha),
  ];
}

function random() {
  let x = Math.sin(seed++) * 10000
  return x - Math.floor(x)
}
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex
  while (0 !== currentIndex) {
    randomIndex = Math.floor(random() * currentIndex)
    currentIndex -= 1
    temporaryValue = array[currentIndex]
    array[currentIndex] = array[randomIndex]
    array[randomIndex] = temporaryValue
  }
  return array
}

if (isWall) {
  createWallTiling()
} else {
  createRhombicosidodecahedron()
}

console.log(outputPythonCoordinates());

</script>
</body>
