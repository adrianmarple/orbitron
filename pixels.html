<html>
<head>
<style>
body, html {
  width: 100%;
  height: 100%;
  margin: 0;
  background-color: black;
  display: flex;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100vh;
  max-width:  100vw;
  height: 100vh;
  max-height: 100vw;
  margin: 0;
}
.button {
  z-index: 1;
  padding: 12px 24px;
  margin: 12px;
  font-size: 24px;
  border: 1px solid black;
  border-radius: 12px;
  background-color: white;
  cursor: pointer;
}
#type-buttons {
  position: absolute;
  right:  24px;
  top: 24px;
}
#download {
  position: absolute;
  right:  24px;
  bottom: 24px;
}
</style>
<head>
<body>
<canvas width="1000" height="1000"></canvas>

<div id="type-buttons">
  <div class="button" id="rhomb">Rhombicosidodecahedron</div>
  <div class="button" id="wall">Wall Tiling</div>
</div>

<div class="button" id="download">Download</div>

<script>
  
const initialSeed = 3
let seed = initialSeed
const PHI = (1 + Math.sqrt(5))/ 2
let verticies = []
let edges = []
let path = []
let isWall = false

function createRhombicosidodecahedron() {
  seed = initialSeed
  isWall = false
  verticies = []
  baseVerticies = [
    [1, 1, Math.pow(PHI, 3)],
    [Math.pow(PHI, 2), PHI, 2 * PHI],
    [2 + PHI, 0 , Math.pow(PHI, 2)],
  ]

  for (let baseVertex of baseVerticies) {
    addPlusMinusVertex(baseVertex)
    addPlusMinusVertex([baseVertex[1], baseVertex[2], baseVertex[0]])
    addPlusMinusVertex([baseVertex[2], baseVertex[0], baseVertex[1]])
  }

  edges = []
  for (let i = 0; i < verticies.length; i++) {
    for (let j = i + 1; j < verticies.length; j++) {
      if (epsilonEquals(d(verticies[i].coordinates, verticies[j].coordinates), 2)) {
        addEdge(verticies[i], verticies[j])
      }
    }
  }
  path = EulerianPath([0], verticies[0])
}

Y_GAP = 4.8
X_GAP = 2.75
function createWallTiling() {
  seed = initialSeed
  isWall = true
  verticies = []
  edges = []
  addDodecagon([-2*X_GAP,0,0])
  addDodecagon([0,0,0])
  addDodecagon([2*X_GAP,0,0])
  addDodecagon([4*X_GAP,0,0])
  addDodecagon([-1*X_GAP,Y_GAP,0])
  addDodecagon([1*X_GAP,Y_GAP,0])
  addDodecagon([3*X_GAP,Y_GAP,0])
  addDodecagon([-1*X_GAP,-Y_GAP,0])
  addDodecagon([1*X_GAP,-Y_GAP,0])
  addDodecagon([3*X_GAP,-Y_GAP,0])
  path = EulerianPath([0], verticies[0])
}

DODEC_RADIUS = 3.86370335645
function addDodecagon(center) {
  let previousVertex = null
  let firstVertex = null
  for (let i = 0; i < 12; i++) {
    let angle = (-0.5 + i)/12 * 2 *Math.PI
    let vertex = addVertex([
      center[0] + Math.sin(angle) * DODEC_RADIUS,
      center[1] + Math.cos(angle) * DODEC_RADIUS,
      0])
    if (!firstVertex) {
      firstVertex = vertex
    }
    if (previousVertex) {
      addEdge(previousVertex, vertex)
    }
    previousVertex = vertex
  }
  addEdge(previousVertex, firstVertex)
}

function addPlusMinusVertex(vertex) {
  for (let i0 = -1; i0 <= 1; i0 += 2) {
    for (let i1 = -1; i1 <= 1; i1 += 2) {
      for (let i2 = -1; i2 <= 1; i2 += 2) {
        addVertex([i0 * vertex[0], i1 * vertex[1], i2 * vertex[2]]);
      }
    }
  }
}

function addVertex(coordinates) {
  for (let existingVertex of verticies) {
    if (epsilonEquals(d(existingVertex.coordinates, coordinates), 0)) {
      return existingVertex
    }
  }
  let vertex = {
    adjacentVertices: [],
    edges: [],
    index: verticies.length,
    coordinates: coordinates,
  }
  verticies.push(vertex)
  return vertex
}

function addEdge(vertex1, vertex2) {
  let edge = {
    index: edges.length,
    verticies: [vertex1, vertex2],
  }
  edges.push(edge)
  vertex1.adjacentVertices.push(vertex2)
  vertex2.adjacentVertices.push(vertex1)
  vertex1.edges.push(edge)
  vertex2.edges.push(edge)
}


function EulerianPath(path, currentVertex) {
  if (path.length === edges.length) {
    return path
  }
  // TODO randomly distribute edges with fixed seed
  let edgesCopy = currentVertex.edges.slice()
  shuffle(edgesCopy)

  for (let edge of edgesCopy) {
    if (!path.includes(edge.index)) {
      let previousVertex = otherVertex(edges[path[path.length - 1]], currentVertex)
      let nextVertex = otherVertex(edge, currentVertex)
      let distance = d(previousVertex.coordinates, nextVertex.coordinates)
      if (!isWall && (epsilonEquals(distance, 2) || epsilonEquals(distance, 3.236))) {
        continue
      }

      path.push(edge.index);
      let finalPath = EulerianPath(path, nextVertex);
      if (finalPath) {
        return finalPath
      } else {
        path.pop()
      }
    }
  }
}

function otherVertex(edge, vertex) {
  let otherVertex = edge.verticies[0]
  if (otherVertex.index === vertex.index) {
    otherVertex = edge.verticies[1]
  }
  return otherVertex
}

function generatePixelInfo() {
  let neighbors = []
  let coords = []
  let nextPixel = {}
  let antipodes = []
  let uniqueToDupe = []
  let dupeToUniques = []

  let vertIndexToCoordIndex = {}
  console.log(edges[0])
  console.log(verticies[2])
  let previousVertex = edges[0].verticies[1]
  for (let edgeIndex of path) {
    let edge = edges[edgeIndex]
    let nextVertex = otherVertex(edge, previousVertex)
    let v1 = previousVertex.coordinates
    let v2 = nextVertex.coordinates

    if (typeof(vertIndexToCoordIndex[previousVertex.index]) != 'undefined') {
      uniqueToDupe.push(vertIndexToCoordIndex[previousVertex.index])
    } else {
      vertIndexToCoordIndex[previousVertex.index] = coords.length
      uniqueToDupe.push(coords.length)
      coords.push(v1)
    }
    uniqueToDupe.push(coords.length)
    coords.push(linearCombo(v2, v1, 1/4))
    uniqueToDupe.push(coords.length)
    coords.push(linearCombo(v2, v1, 2/4))
    uniqueToDupe.push(coords.length)
    coords.push(linearCombo(v2, v1, 3/4))

    previousVertex = nextVertex
  }

  let SIZE = coords.length
  for (let i = 0; i < SIZE; i++) {
    neighbors.push([])
    dupeToUniques.push([])
  }
  let previousIndex = coords.length - 1
  for (let i = 0; i < uniqueToDupe.length; i++) {
    let index = uniqueToDupe[i]
    neighbors[index].push(previousIndex)
    neighbors[previousIndex].push(index)
    previousIndex = index

    dupeToUniques[index].push(i)
  }

  for (let i = 0; i < coords.length; i++) {
    let local_neighbors = neighbors[i]
    for (let n of local_neighbors) {
      expected_n2_coords = delta(scale(coords[n], 2), coords[i])
      for (let n2 of neighbors[n]) {
        if (d(coords[n2], expected_n2_coords) < 0.4) {
          nextPixel[`(${i}, ${n})`] = n2
        }
      }
    }
  }

  for (let i = 0; i < coords.length; i++) {
    let coord = coords[i]
    for (let j = 0; j < coords.length; j++) {
      let coord2 = coords[j]
      if (epsilonEquals(d(coord, scale(coord2, -1)), 0)) {
        antipodes.push(j)
        break
      }
    }
  }

  return {
    SIZE: coords.length,
    isWall,
    coords,
    uniqueToDupe,
    dupeToUniques,
    neighbors,
    nextPixel,
    antipodes,
    // northPole,
    // southPole,
  }
}




const ROTATION_SCALE = 0.01
let previousXY = null
let isRotating = false
document.onmousedown = e => {
  isRotating = true
  previousXY = [e.clientX, e.clientY]
}
document.onmousemove = e => {
  if (isRotating && previousXY) {
    let newXY = [e.clientX, e.clientY]
    rotateX(-ROTATION_SCALE * (newXY[1] - previousXY[1]))
    rotateY(-ROTATION_SCALE * (newXY[0] - previousXY[0]))
    previousXY = newXY
  }
}
document.onmouseup = e => {
  isRotating = false
  previousXY = null
}

let pathIndex = 1;
document.onkeydown = e => {
  if (e.which === 39 || e.which === 38) {
    pathIndex += 1
  }
  if (e.which === 37 || e.which === 40) {
    pathIndex -= 1
  }
}

document.getElementById("rhomb").addEventListener('click', function() {
  createRhombicosidodecahedron()
})
document.getElementById("wall").addEventListener('click', function() {
  createWallTiling()
})

document.getElementById("download").addEventListener('click', function() {
  let fileContent = JSON.stringify(generatePixelInfo(), null, 2)
  let blob = new Blob([fileContent], { type: 'text/plain' })
  let a = document.createElement('a')
  if (isWall) {
    a.download = 'pixels-wall.json'
  } else {
    a.download = 'pixels-rhomb.json'
  }
  a.href = window.URL.createObjectURL(blob)
  a.textContent = 'Download ready';
  a.style='display:none';
  a.click()
})




let c = document.querySelector("canvas")
let ctx = c.getContext("2d")

setInterval(render, 30)

function render() {
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 1000, 1000)

  let subPath = path.slice(0, pathIndex)

  let edgesCopy = edges.slice()
  edgesCopy.sort((a, b) => {
    return b.verticies[0].coordinates[2] - a.verticies[0].coordinates[2]
  })
  for (let edge of edgesCopy) {
    let xy0 = project(edge.verticies[0].coordinates)
    let xy1 = project(edge.verticies[1].coordinates)
    let z = edge.verticies[0].coordinates[2] + 5.5
    ctx.beginPath()

    let alpha = 2/z
    if (subPath.includes(edge.index)) {
      ctx.strokeStyle = `rgb(${255*alpha}, ${255*alpha}, ${255*alpha})`
    } else {
      ctx.strokeStyle = `rgb(${25*alpha}, ${25*alpha}, ${255*alpha})`
    }
    ctx.lineWidth = 100 / (z + 10)
    ctx.moveTo(xy0[0], xy0[1])
    ctx.lineTo(xy1[0], xy1[1])
    ctx.closePath()
    ctx.stroke()
  }
}


function epsilonEquals(a, b, epsilon=0.1) {
  return a - b < epsilon && b - a < epsilon
}

function d(v1, v2) {
  let difference = delta(v1, v2);
  return Math.sqrt(difference[0] * difference[0] +
                   difference[1] * difference[1] +
                   difference[2] * difference[2])
}
function delta(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]]
}

function project(v) {
  const SCALE = 800
  let z = v[2] + 15
  return [500 + v[0] * SCALE / z, 500 + v[1] * SCALE / z]
}

function rotateX(theta) {
  for (let vertex of verticies) {
    let v = vertex.coordinates
    vertex.coordinates = [
        v[0],
        v[1] * Math.cos(theta) + v[2] * Math.sin(theta),
        -v[1] * Math.sin(theta) + v[2] * Math.cos(theta)]
  }
}

function rotateY(theta) {
  for (let vertex of verticies) {
    let v = vertex.coordinates
    vertex.coordinates = [
        v[0] * Math.cos(theta) + v[2] * Math.sin(theta),
        v[1],
        -v[0] * Math.sin(theta) + v[2] * Math.cos(theta)]
  }
}

function scale(v, scalar) {
  return [v[0] * scalar, v[1] * scalar, v[2] * scalar]
}

function linearCombo(v1, v2, alpha) {
  return [
    v1[0] * alpha + v2[0] * (1 - alpha),
    v1[1] * alpha + v2[1] * (1 - alpha),
    v1[2] * alpha + v2[2] * (1 - alpha),
  ]
}

function random() {
  let x = Math.sin(seed++) * 10000
  return x - Math.floor(x)
}
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex
  while (0 !== currentIndex) {
    randomIndex = Math.floor(random() * currentIndex)
    currentIndex -= 1
    temporaryValue = array[currentIndex]
    array[currentIndex] = array[randomIndex]
    array[randomIndex] = temporaryValue
  }
  return array
}

if (isWall) {
  createWallTiling()
} else {
  createRhombicosidodecahedron()
}

</script>
</body>
