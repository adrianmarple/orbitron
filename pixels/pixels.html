<html>
<head>
  <link rel="shortcut icon" href="/favicon.png" />

<style>
body, html {
  width: 100%;
  height: 100%;
  margin: 0;
  background-color: black;
  display: flex;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100vh;
  max-width:  100vw;
  height: 100vh;
  max-height: 100vw;
  margin: 0;
}
.button {
  z-index: 1;
  padding: 12px 24px;
  margin: 12px;
  font-size: 24px;
  border: 1px solid black;
  border-radius: 12px;
  background-color: white;
  cursor: pointer;
}
#type-buttons {
  position: fixed;
  right:  24px;
  top: 24px;
  z-index: 1;
}
#download {
  position: fixed;
  right:  24px;
  bottom: 24px;
}

#settings {
  position: fixed;
  left:  24px;
  top: 24px;
  z-index: 10;
  height: 144px;
  display: grid;
  grid-template-rows: repeat(4, 32px);
  grid-auto-flow: column;
}
#settings > div {
  display: flex;
  font-size: 24px;
  color: white;
  cursor: pointer;
}
#settings input {
  width: 1.3em;
  margin-right: 12px;
}
</style>
</head>
<body>
<canvas width="1000" height="1000"></canvas>

<div id="type-buttons"></div>
<div class="button" id="download">Download</div>

<div id="settings">
  <div>downloadsJSON</div>
  <div>downloadsTopSVG</div>
  <div>downloadsBottomSVG</div>
  <div>downloadsWallSVG</div>
  <div>showVertexNumbers</div>
  <div>showEdgeNumbers</div>
  <div>showLaserSVG</div>
  <div>showWallSVG</div>
  <div>generateWallNumbers</div>
</div>

<script>
const initialSeed = 3
const PHI = (1 + Math.sqrt(5))/ 2

var isWall = false

function reset() {
  verticies = []
  edges = []
  edgeCentersBlacklist = []
  path = []
  seed = initialSeed
  pixelDensity = 1
  imageUrl = null
  centerOnExport = true
  resizeOnExport = true
  isWall = true
  ledAtVertex = true
}
reset()

for (let setting of document.querySelectorAll("#settings > div")) {
  let varName = setting.innerHTML
  window[varName] = false
  let checkbox = document.createElement("input")
  checkbox.type = "checkbox"
  window[varName] = localStorage.getItem(varName) === "true"
  checkbox.checked = window[varName]
  setting.addEventListener("click", () => {
    window[varName] = !window[varName]
    checkbox.checked = window[varName]
    localStorage.setItem(varName, window[varName])
  })
  setting.prepend(checkbox)
}


// ===================== rendering and interaction =====================

const ROTATION_SCALE = 0.01
let previousXY = null
let isDragging = false
document.onmousedown = e => {
  isDragging = true
  previousXY = [e.clientX, e.clientY]
}
document.onmousemove = e => {
  if (!isDragging || !previousXY) return

  let newXY = [e.clientX, e.clientY]
  let deltaX = newXY[0] - previousXY[0]
  let deltaY = newXY[1] - previousXY[1]
  if (isWall) {
    let vector = [deltaX, -deltaY, 0]
    translateAll(scale(vector, 0.1))
  } else {
    rotateXAll(ROTATION_SCALE * deltaY)
    rotateYAll(-ROTATION_SCALE * deltaX)
  }
  previousXY = newXY
}
document.onmouseup = e => {
  isRotating = false
  previousXY = null
}

let pathIndex = -1;
document.onkeydown = e => {
  if (e.which === 39 || e.which === 38) {
    pathIndex += 1
  }
  if (e.which === 37 || e.which === 40) {
    pathIndex -= 1
  }
}

let c = document.querySelector("canvas")
let ctx = c.getContext("2d")

setInterval(render, 30)
function render() {
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 1000, 1000)

  let subPath = null
  if (path) {
    subPath = path.slice(0, pathIndex)
  }

  let maxMagnitude = 0
  for (let vertex of verticies) {
    let point = vertex.coordinates
    maxMagnitude = Math.max(maxMagnitude, magnitude(point))
  }
  let projScale = 8 / (0.6 + maxMagnitude)

  let edgesCopy = edges.slice()
  edgesCopy.sort((a, b) => {
    let pathFactor = 0
    if (path) {
      pathFactor = subPath.includes(a.index) ? 0.1 : 0
      pathFactor += a.isDupe ? 0.01 : 0
      pathFactor -= subPath.includes(b.index) ? 0.1 : 0
      pathFactor -= b.isDupe ? 0.01 : 0
    }
    return pathFactor + b.verticies[0].coordinates[2] - a.verticies[0].coordinates[2]
  })
  for (let edge of edgesCopy) {
    let xy0 = project(edge.verticies[0].coordinates, projScale)
    let xy1 = project(edge.verticies[1].coordinates, projScale)
    let z = edge.verticies[0].coordinates[2] + 5.5
    ctx.beginPath()

    let alpha = 2/z
    if (subPath && subPath.includes(edge.index)) {
      alpha *= 1.5
      ctx.strokeStyle = `rgba(255,255,185,${alpha})`
      if (edge.isDupe) {
        ctx.strokeStyle = `rgba(215,255,255,${alpha})`
      }
    } else {
      ctx.strokeStyle = `rgba(255,25,255,${alpha})`
    }
    ctx.lineWidth = 100 / (z + 10)
    ctx.moveTo(xy0[0], xy0[1])
    ctx.lineTo(xy1[0], xy1[1])
    ctx.closePath()
    ctx.stroke()
  }

  ctx.fillStyle = "white"
  ctx.fontSize = 30
  for (let vertex of verticies) {
    let xy0 = project(vertex.coordinates, projScale)
    if (showVertexNumbers) {
      ctx.fillText(vertex.index, xy0[0] + 4, xy0[1] - 5)
    }
  }
  for (let edge of edges) {
    let center = add(edge.verticies[0].coordinates, edge.verticies[1].coordinates)
    center = scale(center, 0.5)
    let xy0 = project(center, projScale)
    if (showEdgeNumbers && !edge.isDupe) {
      ctx.fillText(edge.index, xy0[0] + 4, xy0[1] - 5)
    }
  }

  document.getElementById("cover").style.display = showLaserSVG ? "block" : "none"
  document.getElementById("wall").style.display = showWallSVG ? "block" : "none"
}


function random() {
  let x = Math.sin(seed++) * 10000
  return x - Math.floor(x)
}
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex
  while (0 !== currentIndex) {
    randomIndex = Math.floor(random() * currentIndex)
    currentIndex -= 1
    temporaryValue = array[currentIndex]
    array[currentIndex] = array[randomIndex]
    array[randomIndex] = temporaryValue
  }
  return array
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

buttonClickMap = {}
function addButton(displayName, onClick) {
  buttonClickMap[displayName] = async () => {
    name = displayName
    localStorage.setItem("button", displayName)
    reset()
    await onClick()
    generatePixelInfo()
  }
  button = document.createElement("div")
  button.innerHTML = displayName

  document.getElementById("type-buttons").appendChild(button)
  button.classList.add("button")
  button.addEventListener('click', () => {
    buttonClickMap[displayName]()
  })
}
setTimeout(() => {
  let buttonToClick = localStorage.getItem("button")
  if (buttonToClick && buttonClickMap[buttonToClick]) {
    buttonClickMap[buttonToClick]()
  }
}, 50)

</script>

<script type="text/javascript" src="topology.js"></script>
<script type="text/javascript" src="data.js"></script>
<script type="text/javascript" src="vector.js"></script>

<script type="text/javascript" src="test/channeltest.js"></script>
<script type="text/javascript" src="THEBOX/button.js"></script>
<script type="text/javascript" src="rhombicosidodecahedron/button.js"></script>
<script type="text/javascript" src="helmet/button.js"></script>
<script type="text/javascript" src="diamond/button.js"></script>
<script type="text/javascript" src="organic wall/button.js"></script>
<script type="text/javascript" src="sixfold/hexcat.js"></script>
<script type="text/javascript" src="spaceinvaders/button.js"></script>
<script type="text/javascript" src="MADE/button.js"></script>
<script type="text/javascript" src="family/crest.js"></script>
<script type="text/javascript" src="family/spiral.js"></script>
<script type="text/javascript" src="family/rectangle.js"></script>
<script type="text/javascript" src="hackerdojo/button.js"></script>
<script type="text/javascript" src="test/letters.js"></script>
<script type="text/javascript" src="sixfold/mandala.js"></script>

<!-- laser.js must come after adding buttons -->
<script type="text/javascript" src="laser.js"></script>
</body>
</html>
