<html>
<head>
<style>
body, html {
  width: 100%;
  height: 100%;
  margin: 0;
  background-color: black;
  display: flex;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100vh;
  max-width:  100vw;
  height: 100vh;
  max-height: 100vw;
  margin: 0;
}
.button {
  z-index: 1;
  padding: 12px 24px;
  margin: 12px;
  font-size: 24px;
  border: 1px solid black;
  border-radius: 12px;
  background-color: white;
  cursor: pointer;
}
#type-buttons {
  position: absolute;
  right:  24px;
  top: 24px;
}
#download {
  position: absolute;
  right:  24px;
  bottom: 24px;
}

</style>
<head>
<body>
<canvas width="1000" height="1000"></canvas>

<div id="type-buttons">
  <div class="button" id="rhomb">Rhombicosidodecahedron</div>
  <div class="button" id="helmet">Helmet</div>
  <div class="button" id="diamond">Diamond grid (wall)</div>
  <div class="button" id="organic">Organic grid (wall)</div>
  <div class="button" id="simple">Simple grid (wall)</div>
  <div class="button" id="square">Square (wall)</div>
  <div class="button" id="dodec">Dodecagons (wall)</div>
</div>

<div class="button" id="download">Download</div>
<script>
  
const initialSeed = 3
let seed = initialSeed
const PHI = (1 + Math.sqrt(5))/ 2
let verticies = []
let edges = []
let edgeCentersBlacklist = []
let path = []
let isWall = false
let name = "rhombicosidodecahedron"

function reset() {
  verticies = []
  edges = []
  edgeCentersBlacklist = []
  path = []
}

function createRhombicosidodecahedron() {
  reset()
  seed = initialSeed
  isWall = false
  name = "rhombicosidodecahedron"
  baseVerticies = [
    [1, 1, Math.pow(PHI, 3)],
    [Math.pow(PHI, 2), PHI, 2 * PHI],
    [2 + PHI, 0 , Math.pow(PHI, 2)],
  ]

  for (let baseVertex of baseVerticies) {
    addPlusMinusVertex(baseVertex)
    addPlusMinusVertex([baseVertex[1], baseVertex[2], baseVertex[0]])
    addPlusMinusVertex([baseVertex[2], baseVertex[0], baseVertex[1]])
  }

  for (let i = 0; i < verticies.length; i++) {
    for (let j = i + 1; j < verticies.length; j++) {
      if (epsilonEquals(d(verticies[i].coordinates, verticies[j].coordinates), 2)) {
        addEdge(verticies[i], verticies[j])
      }
    }
  }
  console.log(edges.length)
  path = EulerianPath([0], verticies[0])
}

function createHelmet() {
  reset()
  seed = initialSeed
  isWall = false
  name = "helmet"
  baseVerticies = [
    [1, 1, Math.pow(PHI, 3)],
    [Math.pow(PHI, 2), PHI, 2 * PHI],
    [2 + PHI, 0 , Math.pow(PHI, 2)],
  ]

  for (let baseVertex of baseVerticies) {
    addPlusMinusVertex(baseVertex)
    addPlusMinusVertex([baseVertex[1], baseVertex[2], baseVertex[0]])
    addPlusMinusVertex([baseVertex[2], baseVertex[0], baseVertex[1]])
  }

  for (let i = 0; i < verticies.length; i++) {
    for (let j = i + 1; j < verticies.length; j++) {
      if (epsilonEquals(d(verticies[i].coordinates, verticies[j].coordinates), 2)) {
        addEdge(verticies[i], verticies[j])
      }
    }
  }

  // find a pentagon
  let previousVertex = edges[0].verticies[0]
  let currentVertex = edges[0].verticies[1]
  let pentagonVertices = [previousVertex, currentVertex]
  for (let i = 0; i < 3; i++) {
    for (let edge of currentVertex.edges) {
      let vertex = otherVertex(edge, currentVertex)
      let dist = d(vertex.coordinates, previousVertex.coordinates)
      if (dist > 3 && dist < 3.5) {
        previousVertex = currentVertex
        currentVertex = vertex
        pentagonVertices.push(vertex)
        break
      }
    }
  }

  function removeEdge(edge) {
    remove(edges, edge)
    for (let vertex of verticies) {
      remove(vertex.edges, edge)
    }
  }

  // Remove pentagon and adjoining edges and compute surrounding dodecagon
  let pentagonCenter = [0,0,0]
  let dodecagonVerticies = []
  for (let vertex of pentagonVertices) {
    pentagonCenter = add(pentagonCenter, vertex.coordinates)
    remove(verticies, vertex)
    for (let edge of vertex.edges) {
      removeEdge(edge)
      dodecagonVerticies.push(edge.verticies[0])
      dodecagonVerticies.push(edge.verticies[1])
    }
  }
  pentagonCenter = normalize(pentagonCenter)
  dodecagonVerticies = dodecagonVerticies.filter(vert => !pentagonVertices.includes(vert))

  // Remove ever other edge from remaining dodecagon
  for (let i = 0; i < 10; i += 2) {
    let v0 = dodecagonVerticies[i]
    let v1 = dodecagonVerticies[i + 1]
    let edge = null
    for (let e of v0.edges) {
      if (e.verticies.includes(v1)) {
        edge = e
        break
      }
    }
    removeEdge(edge)
  }

  for (let i = 0; i < verticies.length; i++) {
    verticies[i].index = i
  }
  for (let i = 0; i < edges.length; i++) {
    edges[i].index = i
  }

  // Rotate helmet to orient dodec/pentagons down
  rotateY(-Math.atan2(pentagonCenter[0], pentagonCenter[2]))
  rotateX(Math.PI)
  for (let vertex of verticies) {
    vertex.ogCoords = scale(vertex.coordinates, SCALE)
  }

  console.log(edges.length)
  path = EulerianPath([dodecagonVerticies[0].edges[0].index], dodecagonVerticies[0])
}




function createDodecagonWallTiling() {
  reset()
  const Y_GAP = 2.4
  const X_GAP = 1.375
  seed = initialSeed
  isWall = true
  name = "dodecwall"
  addDodecagon([-3*X_GAP,-Y_GAP,0])
  addDodecagon([-1*X_GAP,-Y_GAP,0])
  addDodecagon([1*X_GAP,-Y_GAP,0])
  addDodecagon([3*X_GAP,-Y_GAP,0])
  addDodecagon([-2*X_GAP,0,0])
  addDodecagon([0,0,0])
  addDodecagon([2*X_GAP,0,0])
  addDodecagon([-1*X_GAP,Y_GAP,0])
  addDodecagon([1*X_GAP,Y_GAP,0])
  addDodecagon([0,2*Y_GAP,0])
  console.log(edges.length)
  path = EulerianPath([0], verticies[0])
}


function createDiamondWallTiling() {
  reset()
  seed = initialSeed
  isWall = true
  name = "wall"

  for (let i = -6; i <= 6; i++) {
    for (let j = -6; j <= 6; j++) {
      let manhattan = Math.abs(i) + Math.abs(j)
      if (manhattan > 6) {
        continue
      }
      if (manhattan < 3) {
        continue
      }

      addSquare([i,j,0])
    }
  }

  console.log(edges.length)

  path = EulerianPath([0], verticies[1])

  rotateZ(Math.PI/2);
  for (let vertex of verticies) {
    vertex.ogCoords = scale(vertex.coordinates, SCALE)
  }
}

function createOrganicWallTiling() {
  reset()
  seed = initialSeed
  isWall = true
  name = "organic wall"

  addSquare([-4,2,0])
  addSquare([-3,-3,0])
  addSquare([-3,1,0])
  addSquare([-3,3,0])
  addSquare([-2,4,0])
  addSquare([-2,2,0])
  addSquare([-2,0,0])
  addSquare([-2,-2,0])
  addSquare([-2,-4,0])
  addSquare([-1,3,0])
  addSquare([-1,1,0])
  addSquare([-1,-1,0])
  addSquare([-1,-3,0])
  addSquare([-1,-5,0])
  addSquare([0,2,0])
  addSquare([0,0,0])
  addSquare([0,-2,0])
  addSquare([0,-4,0])
  addSquare([1,1,0])
  addSquare([1,-1,0])
  addSquare([1,-3,0])
  addSquare([2,2,0])
  addSquare([2,0,0])
  addSquare([2,-2,0])
  addSquare([3,1,0])
  addSquare([3,-1,0])
  addSquare([4,0,0])
  addSquare([4,-2,0])
  addSquare([5,-1,0])

  console.log(edges.length)

  path = EulerianPath([0], verticies[1])

  for (let vertex of verticies) {
    vertex.ogCoords = scale(vertex.coordinates, SCALE)
  }
}
function createOrganicWallTiling2() {
  reset()
  seed = initialSeed
  isWall = true
  name = "organic wall"

  edgeCentersBlacklist = [
    [0, 3.5, 0],
    [3, -0.5, 0],
    [4, -0.5, 0],
    [4, -1.5, 0],
    [2.5, -1, 0],
    [2.5, -2, 0],
    [3.5, -2, 0],
  ]

  addSquare([-3,-3,0])
  addSquare([1,-3,0])
  addSquare([4,4,0])
  addSquare([-5,3,0])
  addSquare([-1,3,0])
  addSquare([0,3,0])
  addSquare([1,3,0])
  addSquare([5,3,0])
  addSquare([-6,2,0])
  addSquare([-4,2,0])
  addSquare([-2,2,0])
  addSquare([-1,2,0])
  addSquare([1,2,0])
  addSquare([2,2,0])
  addSquare([4,2,0])
  addSquare([6,2,0])
  addSquare([-5,1,0])
  addSquare([-3,1,0])
  addSquare([-2,1,0])
  addSquare([2,1,0])
  addSquare([3,1,0])
  addSquare([5,1,0])
  addSquare([-6,0,0])
  addSquare([-2,0,0])
  addSquare([-1,0,0])
  addSquare([3,0,0])
  addSquare([4,0,0])
  addSquare([-5,-1,0])
  addSquare([-3,-1,0])
  addSquare([-1,-1,0])
  addSquare([0,-1,0])
  addSquare([2,-1,0])
  addSquare([4,-1,0])
  addSquare([-4,-2,0])
  addSquare([-2,-2,0])
  addSquare([0,-2,0])
  addSquare([1,-2,0])
  addSquare([2,-2,0])
  addSquare([3,-2,0])
  addSquare([4,-2,0])

  console.log(edges.length)

  path = EulerianPath([2], verticies[2])

  for (let vertex of verticies) {
    vertex.ogCoords = scale(vertex.coordinates, SCALE)
  }
}

function createWallSquare() {
  reset()
  isWall = true
  name = "square"

  addSquare([0,0,0])

  console.log(edges.length)

  path = EulerianPath([0], verticies[1])

  rotateZ(Math.PI/2);
  for (let vertex of verticies) {
    vertex.ogCoords = scale(vertex.coordinates, SCALE)
  }
}

function createSimpleWallTiling() {
  reset()
  seed = initialSeed
  isWall = true
  name = "simple"

  for (let i = -3; i <= 3; i++) {
    for (let j = -3; j <= 3; j++) {
      let manhattan = Math.abs(i) + Math.abs(j)
      if (manhattan > 1) {
        continue
      }
      addSquare([i,j,0])
    }
  }

  console.log(edges.length)

  path = EulerianPath([0], verticies[1])

  rotateZ(Math.PI/2);
  for (let vertex of verticies) {
    vertex.ogCoords = scale(vertex.coordinates, SCALE)
  }
}




function addSquare(center) {
  addPolygon(4, Math.sqrt(2)/2, center)
}
function addDodecagon(center) {
  addPolygon(12, 3.86370335645/2, center)
}
function addPolygon(sideCount, radius, center) {
  let previousVertex = null
  let firstVertex = null
  for (let i = 0; i < sideCount; i++) {
    let angle = (-0.5 + i)/sideCount * 2 *Math.PI
    let vertex = addVertex([
      center[0] + Math.sin(angle) * radius,
      center[1] + Math.cos(angle) * radius,
      0])
    if (!firstVertex) {
      firstVertex = vertex
    }
    if (previousVertex) {
      addEdge(previousVertex, vertex)
    }
    previousVertex = vertex
  }
  addEdge(previousVertex, firstVertex)
}

function addPlusMinusVertex(vertex) {
  for (let i0 = -1; i0 <= 1; i0 += 2) {
    for (let i1 = -1; i1 <= 1; i1 += 2) {
      for (let i2 = -1; i2 <= 1; i2 += 2) {
        addVertex([i0 * vertex[0], i1 * vertex[1], i2 * vertex[2]]);
      }
    }
  }
}
const SCALE = 1/4.46590101883
function addVertex(coordinates) {
  for (let existingVertex of verticies) {
    if (epsilonEquals(d(existingVertex.coordinates, coordinates), 0)) {
      return existingVertex
    }
  }
  let ogCoords = scale(coordinates, SCALE)
  let vertex = {
    adjacentVertices: [],
    edges: [],
    index: verticies.length,
    coordinates,
    ogCoords,
  }
  verticies.push(vertex)
  return vertex
}

function addEdge(vertex1, vertex2) {
  var edgeCenter = scale(add(vertex1.coordinates, vertex2.coordinates), .5)
  for (let center of edgeCentersBlacklist) {
    if (vectorEquals(edgeCenter, center)) {
      return
    }
  }

  for (let existingEdge of edges) {
    if (existingEdge.verticies[0] == vertex1 && existingEdge.verticies[1] == vertex2) {
      return
    }
    if (existingEdge.verticies[1] == vertex1 && existingEdge.verticies[0] == vertex2) {
      return
    }
  }
  let edge = {
    index: edges.length,
    verticies: [vertex1, vertex2],
  }
  edges.push(edge)
  vertex1.adjacentVertices.push(vertex2)
  vertex2.adjacentVertices.push(vertex1)
  vertex1.edges.push(edge)
  vertex2.edges.push(edge)
}

noncovergenceGuard = 1e6
function EulerianPath(path, currentVertex) {
  noncovergenceGuard -= 1
  if (noncovergenceGuard < 0) {
    path.length = 0
    noncovergenceGuard = 1e6
    return
  }
  if (path.length >= edges.length) {
    return path
  }
  let edgesCopy = currentVertex.edges.slice()
  shuffle(edgesCopy)

  function distance(edge) {
    let previousVertex = otherVertex(edges[path[path.length - 1]], currentVertex)
    let nextVertex = otherVertex(edge, currentVertex)
    return d(previousVertex.coordinates, nextVertex.coordinates)
  }

  // For wall sort by straightest path
  if (name != "rhombicosidodecahedron") {
    edgesCopy.sort((a,b) => distance(b) - distance(a))
  }

  for (let edge of edgesCopy) {
    if (!path.includes(edge.index)) {
      let dist = distance(edge)
      if (name == "rhombicosidodecahedron" && (epsilonEquals(dist, 2) || epsilonEquals(dist, 3.236))) {
        continue
      }

      path.push(edge.index);
      let nextVertex = otherVertex(edge, currentVertex)
      let finalPath = EulerianPath(path, nextVertex);
      if (finalPath) {
        return finalPath
      } else {
        path.pop()
      }
    }
  }
}

function otherVertex(edge, vertex) {
  let otherVertex = edge.verticies[0]
  if (otherVertex.index === vertex.index) {
    otherVertex = edge.verticies[1]
  }
  return otherVertex
}

function generatePixelInfo() {
  let neighbors = []
  let coords = []
  let nextPixel = {}
  let uniqueToDupe = []
  let dupeToUniques = []

  let vertIndexToCoordIndex = {}

  let e0 = edges[path[0]]
  let e1 = edges[path[1]]
  let previousVertex = e0.verticies[0]
  if (e1.verticies[0] == previousVertex || e1.verticies[1] == previousVertex) {
    previousVertex = e0.verticies[1]
  }

  for (let edgeIndex of path) {
    let edge = edges[edgeIndex]
    let nextVertex = otherVertex(edge, previousVertex)
    let v1 = previousVertex.ogCoords
    let v2 = nextVertex.ogCoords

    if (typeof(vertIndexToCoordIndex[previousVertex.index]) != 'undefined') {
      uniqueToDupe.push(vertIndexToCoordIndex[previousVertex.index])
    } else {
      vertIndexToCoordIndex[previousVertex.index] = coords.length
      uniqueToDupe.push(coords.length)
      coords.push(v1)
    }
    uniqueToDupe.push(coords.length)
    coords.push(linearCombo(v2, v1, 1/4))
    uniqueToDupe.push(coords.length)
    coords.push(linearCombo(v2, v1, 2/4))
    uniqueToDupe.push(coords.length)
    coords.push(linearCombo(v2, v1, 3/4))

    previousVertex = nextVertex
  }

  let SIZE = coords.length
  for (let i = 0; i < SIZE; i++) {
    neighbors.push([])
    dupeToUniques.push([])
  }
  let previousIndex = coords.length - 1
  for (let i = 0; i < uniqueToDupe.length; i++) {
    let index = uniqueToDupe[i]
    neighbors[index].push(previousIndex)
    neighbors[previousIndex].push(index)
    previousIndex = index

    dupeToUniques[index].push(i)
  }

  for (let i = 0; i < coords.length; i++) {
    let local_neighbors = neighbors[i]
    for (let n of local_neighbors) {
      furthest_neighbor = null
      max_dist = 0
      for (let n2 of neighbors[n]) {
        let dist = d(coords[n2], coords[i])
        if (dist > max_dist) {
          max_dist = dist
          furthest_neighbor = n2
        }
      }
      nextPixel[`(${i}, ${n})`] = furthest_neighbor
    }
  }

  let info = {
    name,
    SIZE: coords.length,
    isWall,
    coords,
    uniqueToDupe,
    dupeToUniques,
    neighbors,
    nextPixel,
    defaultPulseDirection: [0,1,0],
  }

  if (name == "rhombicosidodecahedron") {
    let antipodes = []
    for (let i = 0; i < coords.length; i++) {
      let coord = coords[i]
      for (let j = 0; j < coords.length; j++) {
        let coord2 = coords[j]
        if (epsilonEquals(d(coord, scale(coord2, -1)), 0)) {
          antipodes.push(j)
          break
        }
      }
      if (antipodes.length <= i) {
        antipodes.push(-1)
      }
    }
    info.antipodes = antipodes
  }

  if (!isWall) {
    let northPole = []
    let southPole = []
    let threshold = 0.94
    if (name == "helmet") {
      threshold = 0.92
    }
    for (var i = 0; i < coords.length; i++) {
      let val = coords[i][2]
      if (val > threshold) {
        northPole.push(i)
      }
      if (name == "helmet" && val < -0.6) {
        southPole.push(i)
      } else if (val < -threshold) {
        southPole.push(i)
      }
    }
    info.northPole = northPole
    info.northPole = southPole
  }

  switch (name) {
    case "rhombicosidodecahedron":
      info.initialPositions = [105,157,117,24,50,202]
      info.southerlyInitialPositions = [79,113,39,352,12,401]
      info.defaultPulseDirection = [0,0,1]
      break
    case "wall":
      info.initialPositions = [432,123,175,79,155,59]
      break
    case "helmet":
      info.initialPositions = [181,155,279,191,255,12]
      info.southerlyInitialPositions = [4,68,129,36,99,64]
      info.defaultPulseDirection = [0,0,1]
      break
  }

  return info
}




const ROTATION_SCALE = 0.01
let previousXY = null
let isRotating = false
document.onmousedown = e => {
  isRotating = true
  previousXY = [e.clientX, e.clientY]
}
document.onmousemove = e => {
  if (isRotating && previousXY) {
    let newXY = [e.clientX, e.clientY]
    rotateX(ROTATION_SCALE * (newXY[1] - previousXY[1]))
    rotateY(-ROTATION_SCALE * (newXY[0] - previousXY[0]))
    previousXY = newXY
  }
}
document.onmouseup = e => {
  isRotating = false
  previousXY = null
}

let pathIndex = 1;
document.onkeydown = e => {
  if (e.which === 39 || e.which === 38) {
    pathIndex += 1
  }
  if (e.which === 37 || e.which === 40) {
    pathIndex -= 1
  }
}

document.getElementById("rhomb").addEventListener('click', function() {
  createRhombicosidodecahedron()
})
document.getElementById("helmet").addEventListener('click', function() {
  createHelmet()
})
document.getElementById("dodec").addEventListener('click', function() {
  createDodecagonWallTiling()
})
document.getElementById("diamond").addEventListener('click', function() {
  createDiamondWallTiling()
})
document.getElementById("organic").addEventListener('click', function() {
  createOrganicWallTiling2()
})
document.getElementById("simple").addEventListener('click', function() {
  createSimpleWallTiling()
})
document.getElementById("square").addEventListener('click', function() {
  createWallSquare()
})

document.getElementById("download").addEventListener('click', function() {
  let fileContent = JSON.stringify(generatePixelInfo(), null, 2)
  let blob = new Blob([fileContent], { type: 'text/plain' })
  let a = document.createElement('a')
  a.download = name + '.json'
  a.href = window.URL.createObjectURL(blob)
  a.textContent = 'Download ready';
  a.style='display:none';
  a.click()
})




let c = document.querySelector("canvas")
let ctx = c.getContext("2d")

setInterval(render, 30)

function render() {
  ctx.fillStyle = "black"
  ctx.fillRect(0, 0, 1000, 1000)

  let subPath = path.slice(0, pathIndex)

  let edgesCopy = edges.slice()
  edgesCopy.sort((a, b) => {
    return b.verticies[0].coordinates[2] - a.verticies[0].coordinates[2]
  })
  for (let edge of edgesCopy) {
    let xy0 = project(edge.verticies[0].coordinates)
    let xy1 = project(edge.verticies[1].coordinates)
    let z = edge.verticies[0].coordinates[2] + 5.5
    ctx.beginPath()

    let alpha = 2/z
    if (subPath.includes(edge.index)) {
      ctx.strokeStyle = `rgb(${255*alpha}, ${255*alpha}, ${255*alpha})`
    } else {
      ctx.strokeStyle = `rgb(${255*alpha}, ${25*alpha}, ${255*alpha})`
    }
    ctx.lineWidth = 100 / (z + 10)
    ctx.moveTo(xy0[0], xy0[1])
    ctx.lineTo(xy1[0], xy1[1])
    ctx.closePath()
    ctx.stroke()
  }
}


function epsilonEquals(a, b, epsilon=0.1) {
  return a - b < epsilon && b - a < epsilon
}
function vectorEquals(v1, v2, epsilon=0.1) {
  return epsilonEquals(d(v1,v2), 0, epsilon)
}


function d(v1, v2) {
  let difference = delta(v1, v2);
  return Math.sqrt(difference[0] * difference[0] +
                   difference[1] * difference[1] +
                   difference[2] * difference[2])
}
function add(v1,v2) {
  return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]]
}
function delta(v1, v2) {
  return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]]
}

function project(v) {
  const SCALE = 800
  let z = v[2] + 15
  return [500 + v[0] * SCALE / z, 500 - v[1] * SCALE / z]
}

function rotateX(theta) {
  for (let vertex of verticies) {
    let v = vertex.coordinates
    vertex.coordinates = [
        v[0],
        v[1] * Math.cos(theta) + v[2] * Math.sin(theta),
        -v[1] * Math.sin(theta) + v[2] * Math.cos(theta)]
  }
}
function rotateY(theta) {
  for (let vertex of verticies) {
    let v = vertex.coordinates
    vertex.coordinates = [
        v[0] * Math.cos(theta) + v[2] * Math.sin(theta),
        v[1],
        -v[0] * Math.sin(theta) + v[2] * Math.cos(theta)]
  }
}
function rotateZ(theta) {
  for (let vertex of verticies) {
    let v = vertex.coordinates
    vertex.coordinates = [
        v[0] * Math.cos(theta) + v[1] * Math.sin(theta),
        -v[0] * Math.sin(theta) + v[1] * Math.cos(theta),
        v[2]]
  }
}

function scale(v, scalar) {
  return [v[0] * scalar, v[1] * scalar, v[2] * scalar]
}
function cross(v1, v2) {
  return [v1[1]*v2[2] - v1[2]*v2[1],
          v1[2]*v2[0] - v1[0]*v2[2],
          v1[0]*v2[1] - v1[1]*v2[0]]
}
function dot(v1, v2) {
  return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]
}
function magnitude(v) {
  return Math.sqrt(dot(v, v))
}
function normalize(v) {
  return scale(v, 1/magnitude(v))
}

function linearCombo(v1, v2, alpha) {
  return [
    v1[0] * alpha + v2[0] * (1 - alpha),
    v1[1] * alpha + v2[1] * (1 - alpha),
    v1[2] * alpha + v2[2] * (1 - alpha),
  ]
}

function remove(array, element)  {
  let index = array.indexOf(element)
  if (index >= 0) {
    array.splice(index, 1)
  }
}

function random() {
  let x = Math.sin(seed++) * 10000
  return x - Math.floor(x)
}
function shuffle(array) {
  let currentIndex = array.length, temporaryValue, randomIndex
  while (0 !== currentIndex) {
    randomIndex = Math.floor(random() * currentIndex)
    currentIndex -= 1
    temporaryValue = array[currentIndex]
    array[currentIndex] = array[randomIndex]
    array[randomIndex] = temporaryValue
  }
  return array
}

createSimpleWallTiling()

</script>

<script type="text/javascript" src="laser.js"></script>
</body>
