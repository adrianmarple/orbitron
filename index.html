<!DOCTYPE html>
<html>
<head>

<meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no"/>
<meta http-equiv="ScreenOrientation" content="autoRotate:disabled">

<title>Super Orbitron</title>
<link rel="shortcut icon" href="/images/favicon.png" />
<script src="/vue.js" type="text/javascript"></script>
<script src="/math.js" type="text/javascript"></script>

<style type="text/css">

:root {
  font-size: min(1.5vh, 2vw);
}

body, #app, .main {
  touch-action: none;
  user-select: none;
  display: flex;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  margin: 0;
}
.main {
  /* Disables pull-to-refresh but allows overscroll glow effects. */
  overscroll-behavior-y: contain;
  overflow-y: hidden;
}

#quit-button, #settings-button, #quit-vote-tally, #game-selection-menu, .main {
  user-select: none;
  -webkit-user-select: none; /* Safari */
  -khtml-user-select: none; /* Konqueror HTML */
  -moz-user-select: none; /* Firefox */
  -ms-user-select: none; /* Internet Explorer/Edge */
}

#settings-button, #quit-button, #rules-button {
  position: fixed;
  cursor: pointer;
  z-index: 2;
  height: 5rem;
  font-size: 2em;
}
#rules-button, #quit-button {
  top:  -1rem;
  left: 1rem;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 1rem;
}
#settings-button {
  right:  1rem;
  top:  1rem;
}
#rules-button {
  top:  5rem;
}

#settings, #game-selection-menu, #rules-splash {
  position: absolute;
  width: 100vw;
  min-height: 100vh;
  box-sizing: border-box;
  padding-top: 8rem;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#rules-splash {
  z-index: 3;
  color:  white;
  font-size: 4rem;
  padding: 2.5rem;
  background: linear-gradient(rgba(212,0,255,1), rgba(122,5,11,1));
}

#rules-splash p {
  margin-top: 2.5rem;
}

#game-selection-menu {
  color:  white;
  z-index: 10;
  background: linear-gradient(rgba(0,212,255,1), rgba(5,122,11,1));
}
#game-selection-menu > div {
  display: flex;
  flex-direction: column;
  align-items: center;
}


#settings {
  z-index: 1;
  background: white;
}
#settings-alignment-guide {
  padding-top: 2.5rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}
.setting {
  font-size: 2em;
  display: flex;
  align-items: center;
  height: 8vw;
  user-select: initial;
  -webkit-user-select: initial; /* Safari */
  -khtml-user-select: initial; /* Konqueror HTML */
  -moz-user-select: initial; /* Firefox */
  -ms-user-select: initial; /* Internet Explorer/Edge */
}
.setting input[type="checkbox"] {
  width: 3rem;
  height: 3rem;
  margin: 0 4rem 0 1rem;
  box-sizing: border-box;
}
.setting textarea {
  width: 15vw;
  height: 7vw;
  line-height: 7vw;
  font-size: 1em;
  text-align: right;
  margin-left: 2vw;
  resize: none;
  overflow: hidden;
  box-sizing: border-box;
}




.header {
  position: fixed;
  left: 5rem;
  right: 5rem;
  top: 10vh;
  padding: 2.5rem;
  text-align: center;
  font-size: 4em;
  display: flex;
  flex-direction: column;
}
#playerMarker {
  position: fixed;
  top: -12.5rem;
  right: -12.5rem;
  transform: rotate(45deg);
  width: 25rem;
  height: 25rem;
  border: 1.5rem solid transparent;
  box-sizing: border-box;
}

#bombPower {
  position: fixed;
  top: 2rem;
  right: 2rem;
  color: white;
  font-size: 4em;
}
#bombPower > img {
  filter: invert(100);
  width: 4rem;
  height: 4rem;
}

.ranking {
  display: flex;
  align-items: center;
  justify-content: center;
}

.players, #victory {
  display: flex;
  justify-content: center;
  align-items: center;
}
.player {
  width: 5rem;
  height: 5rem;
  border-radius: 2.5rem;
  background: black;
  margin: 1.5rem 2.5rem;
}
#victory {
  margin-top: 20vw;
}

.snek {
  height: 3rem;
  border-radius: 1.5rem;
  margin-top: 2rem;
  box-sizing: border-box;
  border:  0.3rem solid black;
  position: relative;
}
.vibrant-snek {
  background-color: rgba(255,255,255, 0.3);
  box-shadow: 0 0 0.5rem 0.5rem white;
  height: 2.5rem;
  border-radius: 1.25rem;
}
.snek-score {
  font-size: 1.5rem;
  color:  white;
  position: absolute;
  height: 2.5rem;
  line-height: 2.5rem;
  right: 1rem;
  top: 0;
}


.joystick-bg {
  background-image: url(images/JoystickBG.png);
  width: 35rem;
  height: 35rem;
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed;
  bottom:  30vh;
}
.joystick-nub {
  background-image: url(images/JoystickNub.png);
  position: relative;
  width: 100%;
  height: 100%;
}
.joystick-bg, .joystick-nub {
  background-size: contain;
  background-position: center;
}

.buttons {
  position: fixed;
  bottom: 5vh;
}
.button {
  border: 2px solid black;
  border-radius: 2.5rem;
  padding: 0.25em 1em;
  margin-top: 2.5rem;
  text-align: center;
  font-size: 4rem;
  cursor: pointer;
  background: white;
  color: #121212;
  position: relative;
}
.vote-tally {
  font-size: 0.5em;
  position: absolute;
  right: 0.5em;
  bottom: 0;
}
#quit-vote-tally {
  font-size: 1.6em;
  left: 13rem;
  top:  5rem;
  z-index: 3;
}

.selected {
  box-shadow: 0 0.4rem 1rem 0.25rem rgba(0, 0, 0, 0.5);
  border-color: #666;
}

.hide {
  display: none !important;
}
.close {
  position: absolute;
  cursor: pointer;
  right: 1rem;
  top:  1rem;
}
.close > svg {
  width: 5rem;
  height: 5rem;
}
</style>
</head>
<body>
<div id=audio-root></div>

<div id=app>
  <svg id="settings-button" @click="showSettings = !showSettings"
      xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 0 24 24" width="48px" fill="#000000">
    <path d="M0 0h24v24H0V0z" fill="none"/><path d="M19.43 12.98c.04-.32.07-.64.07-.98 0-.34-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.09-.16-.26-.25-.44-.25-.06 0-.12.01-.17.03l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.06-.02-.12-.03-.18-.03-.17 0-.34.09-.43.25l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.09.16.26.25.44.25.06 0 .12-.01.17-.03l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.06.02.12.03.18.03.17 0 .34-.09.43-.25l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zm-1.98-1.71c.04.31.05.52.05.73 0 .21-.02.43-.05.73l-.14 1.13.89.7 1.08.84-.7 1.21-1.27-.51-1.04-.42-.9.68c-.43.32-.84.56-1.25.73l-1.06.43-.16 1.13-.2 1.35h-1.4l-.19-1.35-.16-1.13-1.06-.43c-.43-.18-.83-.41-1.23-.71l-.91-.7-1.06.43-1.27.51-.7-1.21 1.08-.84.89-.7-.14-1.13c-.03-.31-.05-.54-.05-.74s.02-.43.05-.73l.14-1.13-.89-.7-1.08-.84.7-1.21 1.27.51 1.04.42.9-.68c.43-.32.84-.56 1.25-.73l1.06-.43.16-1.13.2-1.35h1.39l.19 1.35.16 1.13 1.06.43c.43.18.83.41 1.23.71l.91.7 1.06-.43 1.27-.51.7 1.21-1.07.85-.89.7.14 1.13zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
  </svg>
<!--   <svg id="quit-button" @click="vote('quit')" :class="{selected: self.vote=='quit'}"
      xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000">
    <path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/>
  </svg> -->
  <div id="rules-button"
      class="button"
      @click="showRules=true"
  >
    RULES
  </div>
  <div id="quit-button"
      class="button"
      @click="vote({vote: 'quit'})"
      :class="{selected: self.vote=='quit'}"
  >
    OTHER GAMES
  </div>
  <div id="quit-vote-tally" v-if="voteTally.quit" class="vote-tally">
    {{voteTally.quit}}/{{majorityCount}}
  </div>

  <div v-if="showSettings" id="settings">
    <span style="font-size: 4em">Settings</span>
    <div id="settings-alignment-guide">
      <div v-for="setting in relevantSettings" class="setting">
        {{prettifySettingName(setting.name)}}
        <input
          v-if="setting.boolean"
          type="checkbox"
          v-model.number="config[setting.name]"
          @onchange="updateSettings"
        >
        <textarea
          v-else
          type="number"
          v-model.number="config[setting.name]"
          @keydown="settingsKeydown"
          @change="updateSettings"
        ></textarea>
      </div>
    </div>
  </div>

  <div v-if="BETWEEN_GAMES" id="game-selection-menu">
    <div v-if="connectionStatus == 'CONNECTING'" class="header">
      {{connectionStatus}}
    </div>
    <div v-else>
      <span style="font-size: 4em; margin-bottom: 10vw;">Select a Game</span>
      <div v-for="voteType in voteTypes">
        <div v-if="voteType.divider" style="font-size: 4em; margin-top: 10vw;">
          {{voteType.game}}
        </div>
        <div v-else
            class="button"
            :class="{selected: self.vote==voteType.vote}"
            @click="vote(voteType)"
        >
          {{voteType.vote}}
          <div v-if="voteTally[voteType.vote]" class="vote-tally">
            {{voteTally[voteType.vote]}}/{{majorityCount}}
          </div>
        </div>
      </div>
    </div>
  </div>

  <div v-if="hasNotSeenGame || showRules"
      id="rules-splash"
      @click="dismissRules"
  >
    <div v-if="!localFlags.hasPlayedOnce">
      <p>Welcome to Super Orbitron!</p>
      <p>You all are currently playing <i>{{state.game}}</i>, but there are two other games you can play as well.</p>
      <p>Majority vote is the rule. Vote to start the full game or change to another one.</p>
      <p>Have fun!</p>
      <p style="float: right">- Adrian and Mana</p>
    </div>
    <div v-else-if="SNEKTRON">
      <p>Welcome! You are currently playing Snektron in sandbox mode.</p>
      <p>You can practice moving around and when you want to play the full game press the "Ready!" button.</p>
      <p>Once the game starts, move over the white pixel "apples" to grow longer.</p>
      <p>But if you run into yourself or anyone else, you'll shrink back down.</p>
      <p>A round lasts a minute and a half, and whoever had the longest snek during that time wins!</p>
    </div>
    <div v-else-if="PACMAN">
      <p>Welcome! You are currently playing <i>Co-op Pac-Man</i> in sandbox mode.</p>
      <p>You can practice moving around and when you want to play the full game press the "Ready!" button.</p>
      <p>You are one of several Pac-Men trying to avoid enemy AI ghosts. If you run into a RED ghost you lose collective life.</p>
      <p>Eating a normal pellet earns you 10 points.</p>
      <p>Eating a flashing POWER PELLET earns you 50 points and makes the ghosts scared (blue).</p>
      <p>Eating a BLUE scared ghost earns you 200 points!</p>
      <p>You all win if you achieve the required victory score!</p>
    </div>
    <div v-else-if="BOMBERMAN">
      <p>Welcome! You are currently playing <i>Bomberman</i> in sandbox mode.</p>
      <p>You can practice moving and bombing and when you want to play the full game press the "Ready!" button.</p>
      <p>Tap to place a bomb.</p>
      <p>If you move into a bomb you will kick it and send it traveling.</p>
      <p>The white pixels are walls. You canâ€™t pass through them, but you can blow them up.</p>
      <p>If you hit yourself, you will get stunned.</p>
      <p>If you hit someone else with your bomb you get a point.</p>
      <p>First to 5 points wins!</p>
    </div>

    <div class="close"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg></div>
    <div class="button">Dismiss</div>
  </div>


  <div v-if="connectionStatus == 'CONNECTING'" class="header">
    {{connectionStatus}}
  </div>

  <div v-else-if="connectionStatus != 'CONNECTED'" class="header">
    {{connectionStatus}}
    <br/>
    <br/>
    Tap To Reconnect
  </div>
  
  <div id="queue" v-else-if="!hasClaimed" class="header">
    All the play slots have been claimed.
    <br/>
    <br/>
    Position in queue: {{state.queuePosition}}
  </div>

  <div v-else>

<!--   <div id="playerMarker"
    :style="{ backgroundColor: self.color }"
  ></div>
  <div v-if="BOMBERMAN" id="bombPower">
    <span>{{self.bombPower}}</span>
    <img src="images/explosion.png" />
  </div> -->


  <div v-if="!self.isReady || (mode=='play' && self.isPlaying && self.isAlive)"
    class="joystick-bg"
    :style="joystickBGStyle"
  >
    <div class="joystick-nub" :style="joystickNubStyle"></div>
  </div>

  <div v-if="mode=='start'"
    class="main"
    :style="{ backgroundColor: self.color }"
  >
    <div class="header">
      <div v-if="!self.isReady">
        Drag to Move
        <span v-if="BOMBERMAN">
          <br><br>
          Tap to Bomb
        </span>
      </div>
      <div v-else-if="claimedPlayers.length <= 1">Waiting for another player.</div>
      <div v-else>Waiting for...
        <div class="players">
          <div v-for="player in unreadyPlayers"
            class="player"
            :style="{backgroundColor: player.color}"
          ></div>
        </div>
      </div>
    </div>

    <div class="buttons">
      <div v-if="self.isReady"
        class="button"
        @click.stop="pulse"
      >
        Pulse
      </div>
      <div v-if="self.isReady"
        class="button"
        @click.stop="makeUnready"
      >
        I'm not ready.
      </div>
      <div v-else
        class="button"
        @click.stop="makeReady"
      >
        Ready!
      </div>
    </div>
  </div>

  <div v-else-if="mode=='countdown'" class="main">
    <div class="header">
      <div class="banner">{{Math.round(state.timeRemaining)}}</div>
    </div>
  </div>

  {{mode}}
  <div v-else class="main">
    <div class="header">
      <div v-if="mode=='victory'">
        <div v-if="iAmVictorious">
          Victory!
        </div>
        <div v-else>
          You lost.
        </div>
        <br/>
        <div class="button" @click="vote({vote: 'skip'})">
          Skip
          <div v-if="voteTally['skip']" class="vote-tally">
            {{voteTally['skip']}}/{{majorityCount}}
          </div>
        </div>
        <br/>
      </div>

      <div v-if="BOMBERMAN && config.DEATHMATCH && config.TEAM_MODE">
        <div v-for="team in teamsByRanking" class="ranking">
          <div class="player"
            :style="{backgroundColor: team.color}"
          ></div>
          {{team.killCount}}
        </div>

      </div>
      <div v-if="BOMBERMAN && config.DEATHMATCH && !config.TEAM_MODE">
        <div v-for="player in playersByRanking" class="ranking">
          <div class="player"
            :style="{backgroundColor: player.color}"
          ></div>
          {{player.killCount}}
        </div>
      </div>
      <div v-if="BOMBERMAN && !config.DEATHMATCH && livePlayers.length > 0">
        Live players:
        <div class="players">
          <div v-for="player in livePlayers"
            class="player"
            :style="{backgroundColor: player.color}"
          ></div>
        </div>
      </div>

      <div v-if="PACMAN">
        Score: {{state.data.score}}/{{state.data.victory_score}}
      </div>
      <div v-if="PACMAN && self.isPacman && self.livesLeft >= 0">
        Lives left: {{self.livesLeft}}
      </div>

      <div v-if="SNEKTRON">
        <div v-for="player in playersByRanking">
          <div class="snek"
            :style="{
              backgroundColor: player.color,
              width: (player.score / maxScore * 100) + '%',
            }"
          >
            <div class="vibrant-snek"
              :style="{width: (player.length / player.score * 100) + '%'}"
            ></div>

            <div class="snek-score">{{player.score}}</div>
          </div>
        </div>
      </div>

      <div v-if="mode=='play' && !self.isPlaying">
        You have to wait until next round :(
      </div>
      <div v-else-if="!self.isAlive">
        You died...
      </div>
    </div>
  </div>
</div>

<script>
// To prevent zoom on iOS
document.addEventListener("click", event => {
  if (event.target.tagName != "INPUT") {
    event.preventDefault()
    event.stopPropagation()
  }
})

var app = new Vue({
  el: '#app',
  data: {
    ws: null,
    connectionStatus: "CONNECTING",
    showSettings: false,
    showRules: false,
    oldConfig: null,
    state: {},
    localFlags: {},

    startLocation: null,
    isMoving: false,
    move: [0,0],
    timestamp: 0,

    settingTypes: [
      {game: "bomberman", name: "USE_SHIELDS", boolean: true},
      {game: "bomberman", name: "DEATHMATCH", boolean: true},
      {game: "bomberman", name: "TEAM_MODE", boolean: true},
      {game: "bomberman", name: "FRAG_SUICIDE", boolean: true},
      {game: "bomberman", name: "TAP_TO_DETONATE", boolean: true},
      {game: "bomberman", name: "EXPLODE_ON_IMPACT", boolean: true},
      {game: "bomberman", name: "NEWTONS_CRADLE", boolean: true},
      {game: "bomberman", name: "FIXED_OWNERSHIP", boolean: true},
      {game: "bomberman", name: "TARGET_KILL_COUNT"},
      {game: "bomberman", name: "STARTING_BOMB_POWER"},
      {game: "bomberman", name: "BOMB_FUSE_TIME"},
      {game: "bomberman", name: "PICKUP_CHANCE"},
      {game: "bomberman", name: "NUM_WALLS"},
      {game: "bomberman", name: "BOMB_EXPLOSION_TIME"},
      {game: "bomberman", name: "BATTLE_ROYALE_DURATION"},
      {game: "bomberman", name: "DEATH_CREEP_DURATION"},
      {game: "bomberman", name: "BOMB_MOVE_FREQ"},
      {game: "bomberman", name: "SUICIDE_STUN", boolean: true},

      {game: "pacman", name: "PACMEN_LIVES"},
      {game: "pacman", name: "STARTING_POWER_PELLET_COUNT"},
      {game: "pacman", name: "POWER_PELLET_DURATION"},
      {game: "pacman", name: "PELLET_REGEN_FREQ"},
      {game: "pacman", name: "POWER_PELLET_REGEN_FREQ"},
      {game: "pacman", name: "VICTORY_SCORE"},
      {game: "pacman", name: "MARGINAL_PACMAN_VICTORY_SCORE"},
      {game: "pacman", name: "GHOST_KILL_SCORE"},
      {game: "pacman", name: "PELLET_SCORE"},
      {game: "pacman", name: "POWER_PELLET_SCORE"},
      {game: "pacman", name: "NUM_GHOSTS"},
      {game: "pacman", name: "PACMAN_MOVE_FREQ"},
      {game: "pacman", name: "GHOST_MOVE_FREQ"},

      {game: "snektron", name: "START_LENGTH"},
      {game: "snektron", name: "ADDITIONAL_APPLES"},
      {game: "snektron", name: "ROUND_TIME"},
      {game: "snektron", name: "SNAKE_MOVE_FREQ"},

      {game: "any", name: "STUN_TIME"},
      {game: "any", name: "INVULNERABILITY_TIME"},
      {game: "any", name: "ALLOW_CROSS_TIP_MOVE", boolean: true},
      {game: "any", name: "MOVE_BIAS"},
      {game: "any", name: "MOVE_FREQ"},
    ],

    voteTypes: [
      {game: "snektron", vote: "snektron"},
      {game: "pacman", vote: "pacman"},
      {game: "bomberman", divider: true},
      {
        game: "bomberman", vote: "battle royale",
        settings: {
          USE_SHIELDS: true,
          DEATHMATCH: false,
        }
      },
      {
        game: "bomberman", vote: "deathmatch",
        settings: {
          USE_SHIELDS: false,
          DEATHMATCH: true,
        }
      },
    ],
  },

  created() {

    this.startWebsocket()
    this.warmUpAudio()
    onfocus = () => {
      if (!this.ws) {
          let self=this
          setTimeout(function(){self.startWebsocket();},10)
      }
    };
    onblur = () => {
      if (!this.state.notimeout) {
        this.destroyWebsocket()
        this.connectionStatus = "LOST FOCUS"
      }
    };

    onmousedown = this.handleStart
    ontouchstart = event => {
      this.handleStart(event.touches[0])
    }

    onmouseup = this.handleEnd
    ontouchend = event => {
      this.handleEnd(event.changedTouches[0])
    }

    onmousemove = this.handleChange
    ontouchmove = event => {
      this.handleChange(event.changedTouches[0])
    }
    // Do this last in case localStorage is inaccessible and errors
    this.localFlags = JSON.parse(localStorage.getItem('flags')) || {}
  },

  watch: {
    config: {
      handler: function (val) {
        for (let key in val) {
          if (typeof(val[key]) == "string") {
            try {
              val[key] = parseFloat(val[key])
              if (isNaN(val[key])) {
                val[key] = 0
              }
            } catch(err) {
              // pass
            }
          }
        }

        if (this.oldConfig == null) {
          this.oldConfig = { ...val }
          return
        }

        for (let key in val) {
          if (val[key] != this.oldConfig[key]) {
            this.send({ type: "settings", update: val })
            break
          }
        }
        this.oldConfig = { ...val }
      },
      deep: true
    },
    localFlags: {
      handler: function (val) {
        localStorage.setItem('flags', JSON.stringify(val))
      },
      deep: true
    },
  },

  computed: {
    BETWEEN_GAMES() { return !this.state.game },
    BOMBERMAN() { return this.state.game == 'bomberman' },
    PACMAN() { return this.state.game == 'pacman' },
    SNEKTRON() { return this.state.game == 'snektron' },
    mode() {
      return this.state.gameState
    },
    hasNotSeenGame() {
      return !this.localFlags[this.state.game]
    },
    config() {
      return this.state.config || {}
    },
    hasClaimed() {
      return !isNothing(this.state.self)
    },
    self() {
      if (this.state.players && !isNothing(this.state.self))
        return this.state.players[this.state.self]
      else
        return {}
    },
    myTeam() {
      if(this.state.teams && this.self.team) {
        return this.state.teams[this.self.team]
      } else {
        return []
      }
    },
    teamColor() {
      return (this.config.TEAM_MODE ? this.myTeam : this.self).color
    },

    majorityCount() {
      return Math.ceil(this.claimedPlayers.length / 2)
    },
    voteTally() {
      let tally = {}
      for (let player of this.claimedPlayers) {
        tally[player.vote] = (tally[player.vote] || 0) + 1
      }
      return tally
    },

    claimedPlayers() {
      if (this.state.players) {
        return this.state.players.filter(player => player.isClaimed)
      } else {
        return []
      }
    },
    unreadyPlayers() {
      return this.claimedPlayers.filter(player => !player.isReady)
    },
    livePlayers() {
      return this.claimedPlayers.filter(player => player.isPlaying && player.isAlive)
    },
    playersByRanking() {
      return this.claimedPlayers.sort((p0, p1) => {
        if (this.game == "BOMBERMAN") {
          return p1.killCount - p0.killCount
        } else {
          return p1.score - p0.score
        }
      })
    },

    teamsByRanking() {
      return this.state.teams.sort((p0, p1) => {
        return p1.killCount - p0.killCount
      })
    },

    joystickBGStyle() {
      if (this.startLocation) {
        let joystickElem = document.querySelector(".joystick-bg")
        let joystickWidth
        if (joystickElem) {
          joystickWidth = joystickElem.getBoundingClientRect().width
        } else {
          joystickWidth = window.innerWidth * 0.7
        }
        return {
          left: `calc(${this.startLocation[0] - joystickWidth/2}px)`,
          top:  `calc(${this.startLocation[1] - joystickWidth/2}px)`,
        }
      }
    },
    joystickNubStyle() {
      return {
        right: (25 * this.move[0]) + "%",
        bottom: (25 * this.move[1]) + "%",
      }
    },

    relevantSettings() {
      return this.settingTypes.filter(setting => setting.game == this.state.game || setting.game == "any")
    },

    maxScore() {
      let maxScore = 0
      for (let player of this.state.players) {
        maxScore = Math.max(maxScore, player.score)
      }
      return maxScore
    },
    iAmVictorious() {
        if (!this.state.victor || isNothing(this.state.self)) {
        return false
      }
      if (this.state.victor.players) {
        return this.state.victor.players.includes(this.state.self)
      } else {
        return this.self.color === this.state.victor.color
      }
    },
  },

  methods: {
    send(json) {
      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {
        this.startWebsocket()
      } else if(this.ws.readyState === WebSocket.OPEN) {
        try {
          this.ws.send(JSON.stringify(json))
        } catch (error) {
          this.destroyWebsocket()
          this.startWebsocket()
        }
      }
    },

    destroyWebsocket() {
      if(this.ws) {
        this.ws.close()
        this.ws = null
      }
    },

    startWebsocket() {
      let self=this
      if(self.ws) {
        return // Already trying to establish a connection
      }
      this.connectionStatus = "CONNECTING"
      this.ws = new WebSocket(`ws://${window.location.hostname}:7777`)
      this.ws.onmessage = event => {
        self.connectionStatus = "CONNECTED"
        message = JSON.parse(event.data)
        switch(message.event) {
        case "sound":
          if (message.playerId < 0 || message.playerId == message.self) {
            self.playSound(message.type)
          }
          break
        default:
          self.state = message
          // console.log(message)
          self.$forceUpdate()
        }
      }
      this.ws.onclose = event => {
        console.log("CLOSE")
        self.connectionStatus = "TIMED OUT"
        setTimeout(function(){ self.destroyWebsocket(); })
      }
      this.ws.onerror = event => {
        console.error("ERROR",event)
        self.connectionStatus = "ERROR"
        setTimeout(function(){ self.destroyWebsocket(); })
      }
    },

    handleStart(location) {
      if (this.showSettings) {
        return
      }
      if (this.state.gameState === "start" && this.self.isReady) {
        return
      }

      this.isMoving = true
      this.startLocation = [location.clientX, location.clientY]
      this.timestamp = Date.now()
    },
    handleEnd(location) {
      if (this.showSettings) {
        return
      }
      if (Date.now() - this.timestamp > 10 &&
          Date.now() - this.timestamp < 300 &&
          Math.abs(this.startLocation[0] - location.clientX) < 10 &&
          Math.abs(this.startLocation[1] - location.clientY) < 10) {
        this.send({type: "tap"})
      }
      this.move = [0,0]

      this.send({type: "move", move: this.move})
      this.isMoving = false
    },
    handleChange(location) {
      if (this.showSettings) {
        return
      }
      if (!this.isMoving) {
        return
      }
      let joystickBG = document.querySelector(".joystick-bg")
      if (!joystickBG)
        return
      let joystickWidth = joystickBG.getBoundingClientRect().width
      let maxDisplacement = joystickWidth * 0.25

      this.move = [(this.startLocation[0] - location.clientX) / maxDisplacement,
                   (this.startLocation[1] - location.clientY) / maxDisplacement]
      let moveMagnitude = Math.sqrt(this.move[0] * this.move[0] + this.move[1] * this.move[1])
      if (moveMagnitude > 1) {
        this.move[0] /= moveMagnitude
        this.move[1] /= moveMagnitude

        this.startLocation = [
          location.clientX + this.move[0] * maxDisplacement,
          location.clientY + this.move[1] * maxDisplacement
        ]
      }

      this.send({type: "move", move: this.move})
    },

    dismissRules() {
      if (!this.localFlags.hasPlayedOnce) {
        this.$set(this.localFlags, 'hasPlayedOnce', true)
      } else {
        this.$set(this.localFlags, this.state.game, true)
        this.showRules = false
      }
    },

    vote(vote) {
      vote.type = "vote"
      this.send(vote)
    },
    // quit() {
    //   this.send({type: 'quit'})
    // },
    // startGame(game) {
    //   this.send({type: 'start', game})
    // },

    changeRole(role) { // PACMAN
      this.send({type: "roleChange", role})
    },

    makeReady() {
      this.send({type: "ready"})
    },
    makeUnready() {
      this.send({type: "unready"})
      this.timestamp = 0
    },
    async pulse() {
      this.send({type: "pulse"})
    },

    settingsKeydown(event) {
      if(event.keyCode == 13) {
        event.target.blur()
        event.preventDefault()
      }
    },
    updateSettings() {
      // console.log(this.config)
    },
    prettifySettingName(name) {
      return name.toLowerCase().replaceAll("_", " ")
    },

    warmUpAudio() {
      let names = ["explosion", "hurt", "death"]

      for (let name of names) {
        let audio = document.createElement('audio')
        audio.src = "audio/" + name + ".wav"
        audio.id = "audio-" + name
        audio.clientWidth = 0
        audio.clientHeight = 0
        document.getElementById("audio-root").appendChild(audio)
      }
    },

    playSound(name) {
      console.log(name)
      let audio = document.getElementById("audio-" + name)
      audio.play()
      // audio.addEventListener("ended",function() {
      //   audio.remove()
      //   audio = document.createElement('audio')
      //   audio.src = "audio/" + name + ".wav"
      //   audio.clientWidth = 0
      //   audio.clientHeight = 0
      //   document.getElementById("audio-root").appendChild(audio)
      // });
    },
  },
});

function delay(millis, v) {
  return new Promise(function(resolve) {
    setTimeout(resolve.bind(null, v), millis)
  });
}


playerMarker = document.getElementById("playerMarker")
readyButton = document.getElementById("readyButton")
unreadyButton = document.getElementById("unreadyButton")
banner = document.getElementById("banner")
players = document.getElementById("players")
victory = document.getElementById("victory")
minimap = document.getElementById("minimap")

pixelInfo = null
state = {}


function playExplosion(event) {
  audio = document.createElement('audio');
  audio.src = "explosion.wav";
  audio.clientWidth = 0;
  audio.clientHeight = 0;
  audio.addEventListener("ended",function() {
    this.remove();
  });

  audio.appendChild(document.body);
  auido.play();
}

function isNothing(val) {
  return val === undefined || val === null
}


</script>
</body>
</html>
