<!DOCTYPE html>
<html>
<head>

<meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no"/>
<meta http-equiv="ScreenOrientation" content="autoRotate:disabled">

<title>Super Orbitron</title>
<link rel="shortcut icon" href="/images/favicon.png" />
<script src="/thirdparty/vue.js" type="text/javascript"></script>
<!-- <script src="/thirdparty/math.js" type="text/javascript"></script> -->
<script src="/thirdparty/simple-signal-client.min.js" type="text/javascript"></script>
<script src="/thirdparty/socket.io.min.js" type="text/javascript"></script>

<style type="text/css">

:root {
  font-size: min(1.5vh, 2vw);
}

body, #app, .main {
  touch-action: none;
  user-select: none;
  display: flex;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  margin: 0;
  background-color: var(--self-color);
}
.main {
  overscroll-behavior-y: contain;
  overflow-y: hidden;
  position: relative;
}

#settings-button, #label, #quit-vote-tally, #game-selection-menu, .main {
  user-select: none;
  -webkit-user-select: none; /* Safari */
  -khtml-user-select: none; /* Konqueror HTML */
  -moz-user-select: none; /* Firefox */
  -ms-user-select: none; /* Internet Explorer/Edge */
}

#settings-button {
  position: fixed;
  right: 1rem;
  top: 1rem;
  cursor: pointer;
  z-index: 2;
  height: 5rem;
  width: 5rem;
}

#label {
  font-size: 3.5rem;
}

#settings, #game-selection-menu, #rules-splash, #vote-tooltip, #signup {
  position: absolute;
  width: 100vw;
  min-height: 100vh;
  box-sizing: border-box;
  padding: 6rem 2rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow: scroll;
  overscroll-behavior-y: none;
  top: 0;
  left: 0;
}

#signup {
  z-index: 10;
  background: white;
  display: none;
}

#rules-splash {
  z-index: 3;
  color:  white;
  font-size: 4rem;
  background: linear-gradient(#444, #000);
  overflow: hidden;
}

#rules-splash p {
  margin-top: 2.5rem;
}

#vote-tooltip {
  z-index: 3;
  color: white;
  font-size: 4rem;
  background: rgba(0,0,0, 0.6);
  justify-content: center;
}

#game-selection-menu {
  color:  white;
  z-index: 10;
  background: linear-gradient(rgba(0,212,255,1), rgba(5,122,11,1));
}
#game-selection-menu > div {
  display: flex;
  flex-direction: column;
  align-items: center;
}


#settings {
  z-index: 2;
  background: white;
}
#settings-alignment-guide {
  padding-top: 2.5rem;
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}
.setting {
  font-size: 2em;
  display: flex;
  align-items: center;
  height: 8vw;
  user-select: initial;
  -webkit-user-select: initial; /* Safari */
  -khtml-user-select: initial; /* Konqueror HTML */
  -moz-user-select: initial; /* Firefox */
  -ms-user-select: initial; /* Internet Explorer/Edge */
}
.setting input[type="checkbox"] {
  width: 3rem;
  height: 3rem;
  margin: 0 4rem 0 1rem;
  box-sizing: border-box;
}
.setting textarea {
  width: 15vw;
  height: 7vw;
  line-height: 7vw;
  font-size: 1em;
  text-align: right;
  margin-left: 2vw;
  resize: none;
  overflow: hidden;
  box-sizing: border-box;
}




.header {
  position: fixed;
  left: 5rem;
  right: 5rem;
  top: 15vh;
  padding: 2.5rem;
  text-align: center;
  font-size: 4em;
  display: flex;
  flex-direction: column;
}
.card {
  background: rgba(255,255,255, 0.8);
  border-radius: 1rem;
}
#playerMarker {
  position: fixed;
  top: -12.5rem;
  right: -12.5rem;
  transform: rotate(45deg);
  width: 25rem;
  height: 25rem;
  border: 1.5rem solid transparent;
  box-sizing: border-box;
}

#bombPower {
  position: fixed;
  top: 2rem;
  right: 2rem;
  color: white;
  font-size: 4em;
}
#bombPower > img {
  filter: invert(100);
  width: 4rem;
  height: 4rem;
}

.ranking {
  display: flex;
  align-items: center;
  justify-content: center;
}

.players {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
  justify-content: center;
  align-items: center;
}
#victory {
  display: flex;
  justify-content: center;
  align-items: center;
}
.player {
  width: 5rem;
  height: 5rem;
  border-radius: 2.5rem;
  background: black;
  margin: 1.5rem 2.5rem;
}
#victory {
  margin-top: 20vw;
}

.snek {
  height: 3rem;
  border-radius: 1.5rem;
  margin-top: 2rem;
  box-sizing: border-box;
  border:  0.3rem solid black;
  position: relative;
}
.vibrant-snek {
  background-color: rgba(255,255,255, 0.3);
  box-shadow: 0 0 0.5rem 0.5rem white;
  height: 2.5rem;
  border-radius: 1.25rem;
}
.snek-score {
  font-size: 1.5rem;
  color:  white;
  position: absolute;
  height: 2.5rem;
  line-height: 2.5rem;
  right: 1rem;
  top: 0;
}


.unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.joystick-bg {
  background-image: url(images/JoystickBG.png);
  width: 35rem;
  height: 35rem;
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed;
  bottom:  30vh;
  z-index: 1;
}
.joystick-nub {
  background-image: url(images/JoystickNub.png);
  position: relative;
  width: 100%;
  height: 100%;
}
.joystick-bg, .joystick-nub {
  background-size: contain;
  background-position: center;
}

.buttons {
  position: fixed;
  bottom: 5rem;
  z-index: 2;
}
.button {
  border: 2px solid black;
  border-radius: 2.5rem;
  padding: 0.25em 1em;
  margin-top: 2.5rem;
  text-align: center;
  font-size: 4rem;
  cursor: pointer;
  background: white;
  color: #121212;
  position: relative;
}

#header {
  position: fixed;
  z-index: 2;
  top: 1rem;
  left: 1rem;
  right: 1rem;
  display: flex;
  flex-direction: column;
  align-items: center;
}
#header-buttons {
  display: flex;
}
#header-buttons .button {
  margin: 1rem;
  font-size: 2.5rem;
}

.choice {
  width: 45rem;
  display: flex;
  justify-content: space-between;
}
.choice .button {
  font-size: 2.5rem;
}

.vote-tally {
  position: absolute;
  right: 0;
  top: -0.8rem;
  display: flex;
}
.vote {
  width: 2rem;
  height: 2rem;
  border-radius: 1rem;
  border:  0.1rem solid black;
  margin-left: 0.5rem;
}
.blank.vote {
  background-color: white;
  border-style: dashed;
  opacity: 0.5;
}

.selected {
  box-shadow: 0 0.4rem 1rem 0.25rem rgba(0, 0, 0, 0.5);
  border-color: #666;
}

.hide {
  display: none !important;
}
.close {
  position: fixed;
  cursor: pointer;
  right: 1rem;
  top:  1rem;
}
.close > svg {
  width: 5rem;
  height: 5rem;
}

#mc_embed_signup #mce-success-response {
  color: black !important;
}
#mc_embed_signup .button {
  background-color: #333 !important;
}


.carousel {
  display: flex;
  position: relative;
}
.slide {
  width: 100vw;
  padding:  0 2rem;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.carousel-dots {
  display: flex;
}
.carousel-dots .dot {
  padding: 1rem;
  margin:  0.5rem;
}
.carousel-dots .dot .inner {
  width: 1.2rem;
  height: 1.2rem;
}

</style>
</head>
<body>
<div id=audio-root></div>
<!--
<div id="signup" style="font-size: 2em;">
  <link href="//cdn-images.mailchimp.com/embedcode/classic-10_7.css" rel="stylesheet" type="text/css">
  <div id="mc_embed_signup">
  <form action="https://marplebot.us19.list-manage.com/subscribe/post?u=94eb26fb510a67c9582cfe935&amp;id=235d9f85c5" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank">
    <div id="mc_embed_signup_scroll">
      <h3>Enjoying playing Super Orbitron?</h3>
      <h3>Sign up to learn where it will appear in the future.</h3>
      <div class="mc-field-group">
        <label for="mce-EMAIL">Email Address (required)
      </label>
        <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL">
      </div>
      <div class="mc-field-group">
        <label for="mce-NAME">First Name </label>
        <input type="text" value="" name="NAME" class="" id="mce-NAME">
      </div>
      <div id="mce-responses" class="clear">
        <div class="response" id="mce-error-response" style="display:none"></div>
        <div class="response" id="mce-success-response" style="display:none"></div>
      </div>
      <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button" onclick="startSignup()"></div>
      <div id="mc-embedded-dismiss" class="button" style="font-family: Arial;" onclick="dismissSignup()">
          No it's ok I don't do mailing lists
      </div>
    </div>
  </form>
  </div>
  <script type='text/javascript' src='//s3.amazonaws.com/downloads.mailchimp.com/js/mc-validate.js'></script>
  <script type='text/javascript'>(function($) {
    window.fnames = new Array(); window.ftypes = new Array();fnames[0]='EMAIL';ftypes[0]='email';fnames[1]='NAME';ftypes[1]='text';}(jQuery));var $mcj = jQuery.noConflict(true);

    let interval;
    function startSignup() {
      if (interval) {
        return
      }
      console.log("test")
      let successMessage = document.getElementById("mce-success-response")
      interval = setInterval(() => {
        if (successMessage.style.display == 'block') {
          clearInterval(interval)
          document.getElementById("mc-embedded-subscribe").parentNode.remove()
          document.getElementById("mc-embedded-dismiss").innerHTML = "Dismiss"
        }
      }, 1)
    }

    function dismissSignup() {
      document.getElementById("signup").remove()
    }
  </script>
</div>
-->
<div id=app :style="{ '--self-color': self.color }">
  <div v-if="connectionStatus == 'CONNECTING'" class="header">
    {{connectionStatus}}
  </div>

  <div v-else-if="connectionStatus != 'CONNECTED'" class="header">
    {{connectionStatus}}
    <br/>
    <br/>
    Tap To Reconnect
  </div>

  <div v-else-if="!hasClaimed" id="queue" class="header">
    All the play slots have been claimed.
    <br/>
    <br/>
    Position in queue: {{state.queuePosition}}
  </div>

  <div v-else-if="!self.isReady" id="rules-splash">
    <div class="close" @click="dismissRules">
      <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#fff"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
    </div>
    <div class="carousel" :style="carouselStyle">
      <div v-if="gameInfo" v-for="rule in gameInfo.rules" class="slide">
        <p v-for="paragraph in rule.words">{{paragraph}}</p>
        <img v-if="rule.image" style="width:100%" :src="rule.image" />
      </div>
    </div>

    <div class="carousel-dots">
      <div class="dot"
          v-for="i in carouselSize"
          @click="carouselPosition = i-1; updateCarousel()"
      >
        <div class="inner"
          :style="{background: carouselPosition >= i-1 ? 'white' : '#666'}">
        </div>
      </div>
    </div>

    <div class="button" @click="advanceCarousel">
      {{carouselPosition >= carouselSize-1 ? "Dismiss" : "Next"}}
    </div>
  </div>

  <div v-else-if="showSettings" id="settings">
    <span style="font-size: 4em">Settings</span>
    <div id="settings-alignment-guide">
      <div v-for="(item, key, index) in config" class="setting">
        {{prettifySettingName(key)}}
        <input
          v-if="typeof item == 'boolean'"
          type="checkbox"
          v-model.number="config[key]"
          @change="updateSettings(key)"
        >
        <textarea
          v-else
          type="number"
          v-model.number="config[key]"
          @keydown="settingsKeydown"
          @change="updateSettings(key)"
        ></textarea>
      </div>
    </div>
  </div>

  <div v-else>

<!--   <div id="playerMarker"
    :style="{ backgroundColor: self.color }"
  ></div>
  <div v-if="BOMBERMAN" id="bombPower">
    <span>{{self.bombPower}}</span>
    <img src="images/explosion.png" />
  </div> -->

  <div id="header">
    <div id="label">{{gameInfo.label}}</div>
    <div id="header-buttons">
      <div class="button" style="width: 8rem" @click="showRules()">RULES</div>
      <TallyButton label="SKIP GAME" election="quit" vote="quit"></TallyButton>
    </div>
  </div>

  <div v-if="mode=='play' && self.isAlive"
    class="joystick-bg unselectable"
    :style="joystickBGStyle"
  >
    <div class="joystick-nub" :style="joystickNubStyle"></div>
  </div>


  <div v-if="mode=='start'" class="main">
    <div class="header">
      <div v-if="claimedPlayers.length <= 1">Waiting for another player.</div>
      <div v-else>Waiting for everyone to read the rules.</div>
    </div>
    <div class="buttons">
      <div class="button" @click.stop="pulse">Pulse</div>
    </div>

  </div>

  <div v-else-if="mode=='countdown'" class="main">
    <div class="header">
      <div v-if="state.timeRemaining > 0" class="banner" style="font-size: 3em">{{Math.round(state.timeRemaining)}}</div>
      <div>{{victoryCondition}}</div>
    </div>
  </div>

  <div v-else class="main">
    <div class="header card">
      <div v-if="state.timeRemaining > 0" class="banner" style="font-size: 2em">{{mode=='previctory' ? 0 : Math.round(state.timeRemaining)}}</div>
      <div v-if="mode=='victory'" >
        <div v-if="iAmVictorious">
          Victory!
        </div>
        <div v-else>
          You lost...
        </div>
        <br/>
        <TallyButton label="Continue"
          election="skip"
          vote="yes">
        </TallyButton>
        <TallyButton label="Play again"
          election="playagain"
          vote="yes">
        </TallyButton>
        <br/>
      </div>

      <div v-if="gameInfo.statusDisplay.type == 'battleroyale'">
        Live players:
        <div class="players">
          <div v-for="player in livePlayers"
            class="player"
            :style="{backgroundColor: player.color}"
          ></div>
        </div>
      </div>

      <div v-if="gameInfo.statusDisplay.type == 'cooperativescore'">
        Score: {{state.data.score}}/{{state.data.victory_score}}
        <div v-if="gameInfo.statusDisplay.showLives && self.livesLeft >= 0">
          Lives left: {{self.livesLeft}}
        </div>
      </div>

      <div v-else-if="gameInfo.statusDisplay.type == 'rankedscore'">
        <div v-if="self.isPlaying">
          {{position}} ({{self.score}})
        </div>
        <div v-for="player in playersByRanking">
          <div class="snek"
            :style="{
              backgroundColor: player.color,
              width: (player.score / maxScore * 100) + '%',
            }"
          >
            <div v-if="gameInfo.statusDisplay.innerScore" class="vibrant-snek"
              :style="{width: (player.length / player.score * 100) + '%'}"
            ></div>

            <div class="snek-score">{{player.score}}</div>
          </div>
        </div>
      </div>

      <div v-if="mode=='play' && !self.isPlaying">
        You have to wait until next round :(
      </div>
      <div v-else-if="!self.isAlive">
        You died...
      </div>
    </div>
  </div>
</div>

<svg id="settings-button" @click="showSettings = !showSettings"
    xmlns="http://www.w3.org/2000/svg" height="48px" viewBox="0 0 24 24" width="48px" fill="#000000">
  <path d="M0 0h24v24H0V0z" fill="none"/><path d="M19.43 12.98c.04-.32.07-.64.07-.98 0-.34-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.09-.16-.26-.25-.44-.25-.06 0-.12.01-.17.03l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.06-.02-.12-.03-.18-.03-.17 0-.34.09-.43.25l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.09.16.26.25.44.25.06 0 .12-.01.17-.03l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.06.02.12.03.18.03.17 0 .34-.09.43-.25l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zm-1.98-1.71c.04.31.05.52.05.73 0 .21-.02.43-.05.73l-.14 1.13.89.7 1.08.84-.7 1.21-1.27-.51-1.04-.42-.9.68c-.43.32-.84.56-1.25.73l-1.06.43-.16 1.13-.2 1.35h-1.4l-.19-1.35-.16-1.13-1.06-.43c-.43-.18-.83-.41-1.23-.71l-.91-.7-1.06.43-1.27.51-.7-1.21 1.08-.84.89-.7-.14-1.13c-.03-.31-.05-.54-.05-.74s.02-.43.05-.73l.14-1.13-.89-.7-1.08-.84.7-1.21 1.27.51 1.04.42.9-.68c.43-.32.84-.56 1.25-.73l1.06-.43.16-1.13.2-1.35h1.39l.19 1.35.16 1.13 1.06.43c.43.18.83.41 1.23.71l.91.7 1.06-.43 1.27-.51.7 1.21-1.07.85-.89.7.14 1.13zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
</svg>
<script>

let GAMES_INFO = [
  {
    name: "snektron",
    label: "Snekton",
    rules: [
      {
        words: [
          "Welcome!",
          "You are currently playing Snektron in sandbox mode.",
        ],
      },
      {
        words: ["Eat to grow."],
        image: "/images/snektronEatTutorial.gif",
      },
      {
        words: ["Shrink on contact."],
        image: "/images/snektronShrinkTutorial.gif",
      },
      {
        words: ["Drag to move."],
        image: "/images/snektronMovementTutorial.gif",
      },
    ],
    victoryCondition: "Record longest snake wins",
    statusDisplay: {
      type: "rankedscore",
      innerScore: true,
    },
  },
  {
    name: "colorwar",
    label: "Color War",
    rules: [
      {
        words: [
          "Welcome!",
          "You are currently playing Color War in sandbox mode.",
        ],
      },
      {
        words: [
          "Wherever you go, it turns your color.",
          "Your score is the number of pixels turned your color.",
        ],
      },
    ],
    victoryCondition: "Have the top score at the end of the round.",
    statusDisplay: {
      type: "rankedscore",
    },
  },
  {
    name: "pacman",
    label: "Co-op PacMan",
    rules: [
      {
        words: [
          "Welcome!",
          "You are currently playing Co-op Pac-Man in sandbox mode.",
        ],
      },
      {
        words: ["You are one of several Pac-Men trying to avoid enemy AI ghosts. If you run into a RED ghost you lose a collective life."],
      },
      {
        words: [
          "Eating a normal pellet earns you 10 points.",
          "Eating a flashing POWER PELLET earns you 50 points.",
        ]
      },
      {
        words: [
          "Eating a POWER PELLET also makes the ghosts scared (pink).",
          "Eating a PINK scared ghost earns you 200 points!",
        ],
      },
      {
        words: [
          "You all win if you achieve the required victory score!",
        ],
      },
    ],
    victoryCondition: "You all win if you reach score {{state.data.victory_score}}",
    statusDisplay: {
      type: "cooperativescore",
      showLives: true,
    },
  },
  {
    name: "bomberman",
    label: "Bomberman",
    rules: [
      {
        words: [
          "Welcome!",
          "You are currently playing Bomberman in sandbox mode.",
        ],
      },
      {
        words: ["Tap to place a bomb."],
      },
      {
        words: [
          "Tap again to kick your bomb.",
          "Or if you move into a bomb you will also kick it.",
        ],
      },
      {
        words: [
          "The white pixels are walls.",
          "You can't pass through them, but you can blow them up.",
        ],
      },
      {
        words: [
          "If you hit yourself, you will get stunned.",
          "If you hit someone else with your bomb they get hurt.",
        ],
      },
    ],
    tapInstructions: "Tap to Bomb",
    victoryCondition: "Last one standing wins",
    statusDisplay: {
      type: "battleroyale",
    },
  },
  {
    name: "redlightgreenlight",
    label: "Red Light Pink Light",
    rules: [
      {
        words: [
          "Welcome!",
          "You are currently playing Red Light Pink Light in sandbox mode.",
        ],
      },
      {
        words: ["You can only move when the north pole glows pink."],
      },
      {
        words: [
          "You'll get sent back to the start if you try to move when the north pole is red.",
        ],
      },
    ],
    victoryCondition: "Whoever reaches the top the most times wins!",
    statusDisplay: {
      type: "rankedscore",
    },
  },
]


// To prevent zoom on iOS
document.addEventListener("click", event => {
  if (event.target.tagName != "INPUT") {
    event.preventDefault()
    event.stopPropagation()
  }
})

function uuid() {
  let url = URL.createObjectURL(new Blob());
  URL.revokeObjectURL(url);
  return url.split("/")[3];
};

Vue.component('tallybutton', {
  props: ['label', 'election', 'vote', 'settings'],
  computed: {
    voteCount() {
      let voteCount = 0
      if (this.$root.voteTally[this.election]) {
        voteCount = this.$root.voteTally[this.election][this.vote] || 0
      }
      return voteCount
    },
    voteColors() {
      let icons = this.$root.claimedPlayers
          .filter(player => player.votes[this.election] == this.vote)
          .map(player => player.color)
      // for (let i = icons.length; i < this.$root.majorityCount; i++) {
      for (let i = icons.length; i < this.$root.consensusCount; i++) {
        icons.push("")
      }
      return icons
    },
    selected() {
      if (!this.$root.self.votes) {
        return false
      }
      return this.$root.self.votes[this.election] === this.vote
    },
    style() {
      if (this.voteCount > 0) {
        return {
          zIndex: 100
        }
      } else {
        return {}
      }
    },
  },
  methods: {
    sendVote() {
      this.$root.send({
        type: 'vote',
        election: this.election,
        vote: this.vote,
        settings: this.settings,
      })
    },
  },
  template: `
<div style="position: relative">
  <div class="button"
      @click="sendVote"
      :class="{ selected }"
      :style="style"
  >
    {{ label }}
    <div v-if="voteCount" class="vote-tally">
      <div v-for="color in voteColors"
          class="vote" :class="{ blank: !color }"
          :style="{ background: color }"
      ></div>
    </div>
  </div>
</div>`
})

var app = new Vue({
  el: '#app',
  data: {
    ws: null,
    wrtcs: null,
    signalSocket: null,
    signalClient: null,
    connectionStatus: "CONNECTING",
    state: {},
    localFlags: {},
    showSettings: false,

    startLocation: null,
    isMoving: false,
    move: [0,0],
    timestamp: 0,

    carouselInterval: null,
    carouselPosition: 0,
    carouselCurrentX: 0,

    config: {},
    GAMES_INFO,
    uuid: uuid(),
  },

  created() {

    this.startWebsocket()
    this.startWebRTCSocket()
    this.warmUpAudio()
    onfocus = () => {
      if (!this.ws) {
        let self=this
        setTimeout(function(){self.startWebsocket();},10)
      }
      if (!this.wrtcs) {
        let self = this
        setTimeout(function(){self.startWebRTCSocket();},10)
      }
    };
    onblur = () => {
      if (!this.state.notimeout) {
        this.destroyWebsocket()
        this.destroyWebRTCSocket()
        this.connectionStatus = "LOST FOCUS"
      }
    };

    onmousedown = this.handleStart
    ontouchstart = event => {
      this.handleStart(event.touches[0])
    }

    onmouseup = this.handleEnd
    ontouchend = event => {
      this.handleEnd(event.changedTouches[0])
    }

    onmousemove = this.handleChange
    ontouchmove = event => {
      this.handleChange(event.changedTouches[0])
    }
    // Do this just in case localStorage is inaccessible and errors
    // this.localFlags = JSON.parse(localStorage.getItem('flags')) || {}
  },

  watch: {
    "state.config": function(val, oldValue) {
      if (!oldValue) {
        this.config = { ...val }
        return
      }
      for (let key in val) {
        if (val[key] != oldValue[key]) {
          this.config = { ...val }
          return
        }
      }
    },
    localFlags: {
      handler: function (val) {
        localStorage.setItem('flags', JSON.stringify(val))
      },
      deep: true
    },
  },

  computed: {
    BETWEEN_GAMES() { return !this.state.game },
    gameInfo() {
      for (let info of GAMES_INFO) {
        if (info.name == this.state.game) {
          return info
        }
      }
      return {rules: []}
    },
    victoryCondition() {
      return this.substitute(this.gameInfo.victoryCondition)
    },

    mode() {
      return this.state.gameState
    },
    hasClaimed() {
      return !isNothing(this.state.self)
    },
    self() {
      if (this.state.players && !isNothing(this.state.self))
        return this.state.players[this.state.self]
      else
        return {}
    },

    majorityCount() {
      return Math.ceil((this.claimedPlayers.length + 1) / 2)
    },
    consensusCount() {
      return this.claimedPlayers.length
    },
    voteTally() {
      let tally = {}
      for (const player of this.claimedPlayers) {
        for (const election in player.votes) {
          const vote = player.votes[election]
          if (!tally[election]) {
            tally[election] = {}
          }
          tally[election][vote] = (tally[election][vote] || 0) + 1
        }
      }
      return tally
    },
    isReady() {
      return this.voteTally.ready &&
          this.voteTally.ready.yes > 1 &&
          this.voteTally.ready.yes >= this.consensusCount //this.majorityCount
    },

    claimedPlayers() {
      if (this.state.players) {
        return this.state.players.filter(player => player.isClaimed)
      } else {
        return []
      }
    },
    unreadyPlayers() {
      return this.claimedPlayers.filter(player => !player.isReady)
    },
    livePlayers() {
      return this.claimedPlayers.filter(player => player.isPlaying && player.isAlive)
    },
    playersByRanking() {
      return this.livePlayers.sort((p0, p1) => {
        return (p1.score * 1e12 - p1.scoreTimestamp) - (p0.score * 1e12 - p0.scoreTimestamp)
      })
    },
    position() {
      let rawPosition = this.playersByRanking.indexOf(this.self) + 1
      if (rawPosition % 10 == 1) {
        return rawPosition + "st";
      }
      if (rawPosition % 10 == 2) {
        return rawPosition + "nd";
      }
      if (rawPosition % 10 == 3) {
        return rawPosition + "rd";
      }
      return rawPosition + "th";
    },


    joystickBGStyle() {
      if (this.startLocation) {
        let joystickElem = document.querySelector(".joystick-bg")
        let joystickWidth
        if (joystickElem) {
          joystickWidth = joystickElem.getBoundingClientRect().width
        } else {
          joystickWidth = window.innerWidth * 0.7
        }
        return {
          left: `calc(${this.startLocation[0] - joystickWidth/2}px)`,
          top:  `calc(${this.startLocation[1] - joystickWidth/2}px)`,
        }
      }
    },
    joystickNubStyle() {
      return {
        right: (25 * this.move[0]) + "%",
        bottom: (25 * this.move[1]) + "%",
      }
    },

    maxScore() {
      let maxScore = 0
      for (let player of this.state.players) {
        maxScore = Math.max(maxScore, player.score)
      }
      return maxScore
    },
    iAmVictorious() {
      if (!this.state.victor || isNothing(this.state.self)) {
        return false
      }
      if (this.state.victor.players) {
        return this.state.victor.players.includes(this.state.self)
      } else {
        return this.self.color === this.state.victor.color
      }
    },

    carouselSize() {
      return this.gameInfo.rules.length
    },
    carouselStyle() {
      return {
        left: this.carouselCurrentX + "px",
        width: (this.carouselSize * innerWidth) + "px",
        marginLeft: ((this.carouselSize - 1) * innerWidth) + "px",
      }
    }
  },

  methods: {
    substitute(string) {
      let re = /\{\{(.*?)\}\}/
      let match = re.exec(string)
      while (match) {
        let sub = match[1]
        let value = this
        for (let key of sub.split(".")) {
          value = value[key]
        }
        string = string.replace(re, value)
        match = re.exec(string)
      }
      return string
    },

    send(json) {
      //console.log(json)
      json.timestamp = Date.now()
      let message = null
      try {
        message = JSON.stringify(json)
      } catch(e) {
        console.log("Error stringifying JSON", e)
        return
      }
      if (!this.ws || this.ws.readyState === WebSocket.CLOSED) {
        this.startWebsocket()
      } else if(this.ws.readyState === WebSocket.OPEN) {
        try {
          this.ws.send(message)
        } catch (error) {
          this.destroyWebsocket()
          this.startWebsocket()
        }
      }
      if(!this.wrtcs) {
        this.startWebRTCSocket()
      } else {
        try {
          this.wrtcs.send(message)
        } catch(e) {
          this.destroyWebRTCSocket()
          this.startWebRTCSocket()
        }
      }
    },
    pulse() {
      this.send({type: "pulse"})
    },
    advance(from) {
      this.send({type: "advance", from})
    },

    destroyWebsocket() {
      if(this.ws) {
        this.ws.close()
        this.ws = null
      }
    },

    startWebsocket() {
      let self=this
      if(self.ws) {
        return // Already trying to establish a connection
      }
      this.connectionStatus = "CONNECTING"
      this.ws = new WebSocket(`ws://${window.location.hostname}:7777${window.location.pathname}/${this.uuid}`)
      this.ws.onmessage = event => {
        self.connectionStatus = "CONNECTED"
        self.handleMessage(event.data)
      }
      this.ws.onclose = event => {
        console.log("CLOSE")
        self.connectionStatus = "TIMED OUT"
        setTimeout(function(){ self.destroyWebsocket(); })
      }
      this.ws.onerror = event => {
        console.error("ERROR",event)
        self.connectionStatus = "ERROR"
        setTimeout(function(){ self.destroyWebsocket(); })
      }
    },

    destroyWebRTCSocket() {
      if(this.wrtcs) {
        this.wrtcs.destroy()
        this.wrtcs = null
      }
      if(this.signalSocket) {
        this.signalSocket.close()
        this.signalSocket = null
      }
      this.signalClient = null
    },

    startWebRTCSocket() {
      let self=this
      if(self.signalClient) {
        return // Already trying to establish a connection
      }
      // this.connectionStatus = "CONNECTING"
      self.signalSocket = io(location.origin)
      self.signalClient = new SimpleSignalClient(self.signalSocket)
      self.signalClient.on('discover', async (allIDs) => {
        allIDs.forEach(async function(id){
          try {
            const { peer } = await self.signalClient.connect(id,{clientID:self.uuid})
            // self.connectionStatus = "CONNECTED"
            self.wrtcs = peer
            peer.on('data', function(data){
              self.handleMessage(data.toString())
            })
            peer.on('close',function(){
              // self.connectionStatus = "TIMED OUT"
              setTimeout(function(){ self.destroyWebRTCSocket(); })
            })
            peer.on('error', (err) => {
              console.error("ERROR",err)
              self.connectionStatus = "ERROR"
              setTimeout(function(){ self.destroyWebRTCSocket(); })
            })
          } catch(e) {
            console.log("WebRTC Connection error",e)
            self.destroyWebRTCSocket()
          }
        })
      })
      self.signalClient.discover({orbID:window.location.pathname.substr(1)})
    },

    handleMessage(data) {
      //TODO check and handle timestamp of data
      let self = this
      message = JSON.parse(data)
      switch(message.event) {
      case "sound":
        if (message.playerId < 0 || message.playerId == message.self) {
          self.playSound(message.type)
        }
        break
      default:
        if (message.self != this.state.self) {
          window.parent.postMessage({self: message.self}, '*')
        }
        self.state = message
        // console.log(message)
        self.$forceUpdate()
      }
    },

    handleStart(location) {
      if (this.showSettings) {
        return
      }
      this.isMoving = true
      this.startLocation = [location.clientX, location.clientY]
      this.timestamp = Date.now()
    },
    handleEnd(location) {
      if (this.showSettings || !this.self.isReady) {
        return
      }
      if (Date.now() - this.timestamp > 10 &&
          Date.now() - this.timestamp < 300 &&
          Math.abs(this.startLocation[0] - location.clientX) < 10 &&
          Math.abs(this.startLocation[1] - location.clientY) < 10) {
        this.send({type: "tap"})
      }
      this.move = [0,0]

      this.send({type: "move", move: this.move})
      this.isMoving = false
    },
    handleChange(location) {
      if (this.showSettings) {
        return
      }
      if (!this.isMoving) {
        return
      }
      let joystickBG = document.querySelector(".joystick-bg")
      if (!joystickBG)
        return
      let joystickWidth = joystickBG.getBoundingClientRect().width
      let maxDisplacement = joystickWidth * 0.25

      this.move = [(this.startLocation[0] - location.clientX) / maxDisplacement,
                   (this.startLocation[1] - location.clientY) / maxDisplacement]
      let moveMagnitude = Math.sqrt(this.move[0] * this.move[0] + this.move[1] * this.move[1])
      if (moveMagnitude > 1) {
        this.move[0] /= moveMagnitude
        this.move[1] /= moveMagnitude

        this.startLocation = [
          location.clientX + this.move[0] * maxDisplacement,
          location.clientY + this.move[1] * maxDisplacement
        ]
      }

      this.send({type: "move", move: this.move})
    },

    showRules() {
      this.send({ type: 'unready' })
    },

    dismissRules() {
      this.$set(this.localFlags, 'hasPlayedOnce', true)
      this.$set(this.localFlags, this.state.game, true)
      this.send({ type: 'ready' })
      this.carouselPosition = 0
      this.carouselCurrentX = 0
      if (this.carouselInterval) {
        clearInterval(this.carouselInterval)
        this.carouselInterval = null
      }
    },
    // displaySignup() {
    //   if (this.localFlags.hasSeenSignup) {
    //     return
    //   }
    //   this.$set(this.localFlags, 'hasSeenSignup', true)
    //   document.getElementById("signup").style.display = 'block'
    // },

    settingsKeydown(event) {
      if(event.keyCode == 13) {
        event.target.blur()
        event.preventDefault()
      }
    },
    updateSettings(settingsName) {
      this.send({ type: "settings", update: {[settingsName]: this.config[settingsName] }})
    },
    prettifySettingName(name) {
      return name.toLowerCase().replaceAll("_", " ")
    },

    warmUpAudio() {
      let names = ["explosion", "hurt", "death"]

      for (let name of names) {
        let audio = document.createElement('audio')
        audio.src = "audio/" + name + ".wav"
        audio.id = "audio-" + name
        audio.clientWidth = 0
        audio.clientHeight = 0
        document.getElementById("audio-root").appendChild(audio)
      }
    },

    playSound(name) {
      console.log(name)
      let audio = document.getElementById("audio-" + name)
      audio.play()
      // audio.addEventListener("ended",function() {
      //   audio.remove()
      //   audio = document.createElement('audio')
      //   audio.src = "audio/" + name + ".wav"
      //   audio.clientWidth = 0
      //   audio.clientHeight = 0
      //   document.getElementById("audio-root").appendChild(audio)
      // });
    },

    advanceCarousel() {
      this.carouselPosition += 1
      if (this.carouselPosition >= this.carouselSize) {
        this.dismissRules()
      }
      this.updateCarousel()
    },
    updateCarousel() {
      if (this.carouselInterval) {
        return
      }
      this.carouselInterval = setInterval(() => {
        let targetX = innerWidth * -this.carouselPosition
        const alpha = 0.75
        this.carouselCurrentX = alpha * this.carouselCurrentX + (1 - alpha) * targetX
        this.$forceUpdate()
        if (Math.abs(this.carouselCurrentX - this.targetX) < 0.1) {
          clearInterval(this.carouselInterval)
          this.carouselInterval = null
        }
      }, 33)
    },
  },
});

function delay(millis, v) {
  return new Promise(function(resolve) {
    setTimeout(resolve.bind(null, v), millis)
  });
}


playerMarker = document.getElementById("playerMarker")
readyButton = document.getElementById("readyButton")
unreadyButton = document.getElementById("unreadyButton")
banner = document.getElementById("banner")
players = document.getElementById("players")
victory = document.getElementById("victory")
minimap = document.getElementById("minimap")

pixelInfo = null
state = {}


function playExplosion(event) {
  audio = document.createElement('audio');
  audio.src = "explosion.wav";
  audio.clientWidth = 0;
  audio.clientHeight = 0;
  audio.addEventListener("ended",function() {
    this.remove();
  });

  audio.appendChild(document.body);
  auido.play();
}

function isNothing(val) {
  return val === undefined || val === null
}

</script>
</body>
</html>
